---
title: "Entrega grupo 7"
subtitle: "Citas electorales al Congreso de los Diputados de España"
author: "Mario Camacho, Diana Cáceres, Vicente Pantoja"
format: 
  revealjs:
    theme: [default, styleOK.scss]
    toc: false
    toc-location: right
    toc-title: Índice
    menu:
      side: left
      width: normal
    footer: "Máster de Bioestadística • G7 • curso 2.023-2.024"
    slide-number: c/t
editor: visual
---

```{r paquetes}
#| warning: false
knitr::opts_chunk$set(echo = F) #echo: false por defecto
options(scipen=999) #Para evitar el uso de notación científica para números
#rm(list = ls()) # Borramos variables de environment
# remotes::install_github("davidsjoberg/ggsankey")
# Cargar librerias
library(tidyverse)
library(skimr)
library(stringi)
library(lubridate)
library(glue)
library(ggthemes)
library(showtext)
library(ggridges)
library(ggsci)
library(dplyr)
library(scales)
library(microbenchmark)
library(gridExtra)
library(ggparliament)
library(ggsankey)
library(ggbreak)
library(magick)
library(outliers)
```

```{r}
# NO TOQUES NADA
#| echo: true
datos_elecciones <- read_csv(file = "C:/Users/MarioC/Documents/Master_Bioestadistica/Software_23_24/GRUPAL/datos/datos_elecciones_brutos.csv")
cod_mun <- read_csv(file = "C:/Users/MarioC/Documents/Master_Bioestadistica/Software_23_24/GRUPAL/datos/cod_mun.csv")
encuestas <- read_csv(file = "C:/Users/MarioC/Documents/Master_Bioestadistica/Software_23_24/GRUPAL/datos/historical_surveys.csv")
siglas <- read_csv(file = "C:/Users/MarioC/Documents/Master_Bioestadistica/Software_23_24/GRUPAL/datos/siglas.csv")

#colores <- c("#76b3dd", "#FF0000", "#de6c25", "#FF5824", "#00bda1", "#ffbf41", "#E61455", 
#             "#008135", "#F6350B", "#6D50B3", "#73B446", "#3399FF", "gray40")

font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()

colores <- c("#e3005a","#00d3da", "#4e5dff", "#efae00", "#001352", "#b7ff6b", "#ff4526", "#260015",  "#ffeaa2", "#5dabff", "#8a8100", "#007a72", "#432500")

tema_7 <- theme_minimal() +
  theme(text = element_text(family = "Roboto"),
        plot.title = element_text(size = 18, face = "bold"),
        plot.caption = element_text(face = "italic")) 
```

------------------------------------------------------------------------

## Entrega

La práctica versará entorno a los **archivos de datos electorales** que ya hemos trabajado, recopilando datos de citas electorales al Congreso de los Diputados de España desde 2008 hasta 2019.

------------------------------------------------------------------------

## Bases de datos

Para el desarrollo del presente trabajo, se han considerado las siguientes bases de datos:

::: columns
::: {.column width="37%"}
![](https://raw.githubusercontent.com/MarioC0093/Software_GRUPAL_7/main/Versiones%20finales/imagenes/lista_paquete.JPG)
:::

::: {.column width="63%"}
::: incremental
-   **datos_elecciones**: archivo con los datos electorales al Congreso desde 2.008 hasta las dos de 2.019.

-   **cod_mun**: archivo con los códigos y nombres de cada municipio

-   **siglas**: siglas y nombres asociados a cada partido

-   **encuestas**: tabla de encuestas electorales desde 1.982.
:::
:::
:::

------------------------------------------------------------------------

## DATOS ELECCIONES

Esta base de datoses un tibble de 48.737 x 471 lo que impide su comprensión y un correcto análisis de datos.

-   Pivot longer: es preferible una columna con todos los partidos políticos y otra con el número de votos de cada uno en cada municipio en cada una de las elecciones

-   Datos eliminados:

Valores NA: partidos que no han recibido votos en esas elecciones, NA no significa que sea un dato faltante si no que no ha recibido ningún voto

Columnas que no aportan información, es decir, aquellas que tengan un único valor/constante: tipo elección, código distrito electoral y vuelta.

```{r}
#| results: hold
cols_sin_informacion <- datos_elecciones |> select(1:15) |>
  summarise(across(everything(), n_distinct)) |> pivot_longer(cols = everything()) |> 
  filter(value==1) |> select(name) |> pull()

datos_elecciones <- datos_elecciones |> select(-all_of(cols_sin_informacion))
```

## Datos elecciones

Se obtiene un tibble de 14 columnas.

```{r}
#| echo: false
datos_elecciones <- datos_elecciones |>
  pivot_longer(cols = -c(anno:votos_candidaturas),
               names_to = "partido_politico",
               values_to = "votos") |>
  drop_na(votos)
datos_elecciones |> head()
```

Se crean dos nuevas columnas.

-   *fecha* (identificador de las elecciones)
-   *id_mun* (funciona como id para unir las bases de datos datos_elecciones y cod_mun)

Se eliminan las columnas *anno*, *mes*, *codigo_provincia* y *codigo_municipio"* pero se mantiene la columna *codigo_ccaa*.

```{r}
datos_elecciones <- datos_elecciones |>
  mutate(fecha = glue("{anno}-{mes}"),
         cod_mun = glue("{codigo_ccaa}-{codigo_provincia}-{codigo_municipio}"),
         .before = "codigo_ccaa") |> 
  select(-c(anno, mes, codigo_municipio))
  # select(-c(anno, mes, codigo_provincia, codigo_municipio)) <- Mario: creo que es esta
```

## CÓDIGOS MUNICIPIOS

Unimos las tablas *datos_elecciones* y *cod_mun* a fin de que en la base final aparezca el nombre de los municipios.

```{r}
datos_elecciones <- datos_elecciones |> 
  inner_join(cod_mun, by = "cod_mun") |> 
  relocate(municipio, .after = cod_mun)
```

La unificación estas dos bases de datos es necesaria para poder realizar análisis geográficos.

![](https://raw.githubusercontent.com/MarioC0093/Software_GRUPAL_7/main/Versiones%20finales/imagenes/mapa_banderas.jpg)

## SIGLAS

Se normalizan las siglas de los partidos políticos. Por ejemplo, tres denominaciones de Convergència i Unió se unifican en unas únicas siglas para agrupar la información de este partido.

```{r}
siglas |>
  filter(str_detect(str_to_lower(denominacion), "^conver.*uni|^conver.*cata")) |> 
  distinct() |> 
  mutate(siglas_new = "CiU")
```

Se realiza la siguiente normalización:

```{r}
#| echo: true
#| code-fold: true
siglas <- siglas |> 
  mutate(siglas=case_when(str_detect(str_to_lower(denominacion), ".*part.*popul|pp") ~ "PP",
                          # P.P-E.U. nos interesa como PP
                          # listas conjuntas con el Partido Popular en las elecciones municipales y autonómicas de 2007
                          # en las elecciones generales de 2011 se presentó en coalición con el Partido Popular
                          str_detect(str_to_lower(denominacion), "^part.*socialist|^socialist.*teruel") ~ "PSOE",
                          str_detect(str_to_lower(denominacion), "^ciudadanos.*partido|^ciutadans") ~ "C's",
                          str_detect(str_to_lower(denominacion), "vasco") ~ "PNV",
                          str_detect(str_to_lower(siglas), "bng") ~ "BNG",
                          str_detect(str_to_lower(siglas), "comprom") &
                            !str_detect(siglas,"^0-9")~ "COMPROMÍS", # para evitar COMPROMÍS 2
                          str_detect(str_to_lower(denominacion), "^conver.*uni|^conver.*cata") ~ "CiU",
                          # El 19 de septiembre de 1978 [Convergencia Democrática de Cataluña] se coalizó con Unió Democràtica de Catalunya
                          # El 18 de junio de 2015 Convergència Democràtica de Catalunya anunció el fin de Convergència i Unió 
                          str_detect(str_to_upper(denominacion), "VERDES|PODEM|EZKER|COMUNISTA|ZQUIERDA REPUBLICANA
                                     |VERDS|IZQUIERDA UNIDA|EN MAREA|UNIDAD POPULAR|EQUO") & # importante que el | esté en esta línea y no al final de la anterior
                            !str_detect(str_to_upper(stringi::stri_trans_general(denominacion, id = "Latin-ASCII")), "MAS PAIS") ~ "UP",
                          str_detect(str_to_lower(siglas), "erc") |
                            str_detect(tolower(denominacion), "esquerra republicana") ~ "ERC",
                          # FRONT PEL PAIS VALENCIA-ERC --> ERC
                          # https://www.vilaweb.cat/noticia/1142933/20000710/front-pais-valencia-fusionara-erc.pdf
                          str_detect(str_to_upper(denominacion), "EH|EUSKO|ARALAR") | 
                            str_detect(str_to_upper(siglas), "EH|EUSKO|ARALAR")~ "EH - BILDU",
                          str_detect(str_to_upper(stringi::stri_trans_general(denominacion, id = "Latin-ASCII")), "MAS PAIS") ~ "MÁS PAÍS",
                          str_detect(str_to_upper(denominacion), "VOX") ~ "VOX",
                          TRUE ~ "Otros"),
         .after = denominacion)

siglas <- siglas |>  
  select(denominacion, siglas) |>  
  distinct()
```

## Siglas

Se procede a añadir las siglas de los partidos a la tabla de datos_encuestas.

```{r}
#| warning: false
#| code-fold: true

datos_elecciones_siglas <- datos_elecciones |>
  left_join(siglas, by = c("partido_politico" = "denominacion")) |> 
  relocate(siglas, .before = partido_politico)
```

```{r}
datos_elecciones_siglas |> filter(is.na(siglas)) |> distinct(partido_politico,siglas) |> arrange(partido_politico)
```

No todos los partidos políticos de la base de datos de elecciones se encuentran en la base de datos de siglas.

La tabla de dimensiones *siglas* no nos es útil por no abarcar todas las casuísticas de la tabla de hechos. Realizamos la normalización directamente sobre la base de datos de *elecciones*.

```{r}
#| echo: true
#| code-fold: true

datos_elecciones <- datos_elecciones |> 
  mutate(siglas = case_when(str_detect(str_to_lower(partido_politico), ".*part.*popul|pp") ~ "PP",
                          # P.P-E.U. nos interesa como PP
                          # listas conjuntas con el Partido Popular en las elecciones municipales y autonómicas de 2007
                          # en las elecciones generales de 2011 se presentó en coalición con el Partido Popular
                          str_detect(str_to_lower(partido_politico), "^part.*socialist|^socialist.*teruel") ~ "PSOE",
                          str_detect(str_to_lower(partido_politico), "^ciudadanos.*partido|^ciutadans") ~ "C's",
                          str_detect(str_to_lower(partido_politico), "vasco") ~ "PNV",
                          str_detect(str_to_lower(partido_politico), "galego") ~ "BNG",
                          str_detect(str_to_lower(partido_politico), "comprom") &
                            !str_detect(partido_politico,"^0-9")~ "COMPROMÍS", # para evitar COMPROMÍS 2
                          str_detect(str_to_lower(partido_politico), "^conver.*uni|^conver.*cata") ~ "CiU",
                          # El 19 de septiembre de 1978 [Convergencia Democrática de Cataluña] se coalizó con Unió Democràtica de Catalunya
                          # El 18 de junio de 2015 Convergència Democràtica de Catalunya anunció el fin de Convergència i Unió 
                          str_detect(str_to_upper(partido_politico), "VERDES|PODEM|EZKER|COMUNISTA|ZQUIERDA REPUBLICANA
                                     |VERDS|IZQUIERDA UNIDA|EN MAREA|UNIDAD POPULAR|EQUO") & # importante que el | esté en esta línea y no al final de la anterior
                            !str_detect(str_to_upper(stringi::stri_trans_general(partido_politico, id = "Latin-ASCII")), "MAS PAIS") ~ "UP",
                          partido_politico == "IU" ~ "UP",
                          str_detect(str_to_lower(partido_politico), "erc") |
                            str_detect(tolower(partido_politico), "esquerra republicana") ~ "ERC",
                          # FRONT PEL PAIS VALENCIA-ERC --> ERC
                          # https://www.vilaweb.cat/noticia/1142933/20000710/front-pais-valencia-fusionara-erc.pdf
                          str_detect(str_to_upper(partido_politico), "EH|EUSKO|ARALAR") | 
                            str_detect(str_to_upper(partido_politico), "EH|EUSKO|ARALAR")~ "EH - BILDU",
                          str_detect(str_to_upper(stringi::stri_trans_general(partido_politico, id = "Latin-ASCII")), "MAS PAIS") ~ "MÁS PAÍS",
                          str_detect(str_to_upper(partido_politico), "VOX") ~ "VOX",
                          TRUE ~ "Otros")) #
#|>   select(partido_politico)
```

## Siglas

Con los nombre de los partidos políticos estandarizados a una lista de trece siglas (facor siglas), agrupamos la información que antes estaba a nivel de partido político a nivel de siglas.

Seleccionamos una muestra aleatoria del dataset y vemos de qué forma es más rápida la agrupación de la información:

-   summarise con todas las columnas en el by (se agrega directamente la información).
-   mutate con las columnas que sirven de identificador del dato y posterior distinct (se calcula la información agrupada y luego se quitan datos duplicados).

```{r}
sample_1 <- datos_elecciones |>
  slice_sample(prop = 0.05, by = c(fecha, codigo_ccaa))
```

::: columns
::: {.column width="50%"}
```{r}
# validacion:
datos_elecciones |> count(fecha, codigo_ccaa) |>
  mutate(p = round(100*n/sum(n),1), .by = fecha) |>
  slice_max(fecha) |> head(5) |> rename(`Freq muestra(n)`=n,"Freq muestra(%)"=p)
```
:::

::: {.column width="50%"}
```{r}
# validacion:
sample_1 |> count(fecha, codigo_ccaa) |>
  mutate(p = round(100*n/sum(n),1), .by = fecha) |>
  slice_max(fecha) |> head(5) |> rename(`Freq muestra(n)`=n,"Freq muestra(%)"=p)
```
:::
:::

## Siglas

La función microbenchmark, nos permite comparar el tiempo de ejecución entre dos expresiones.

```{r}
#| echo: true
microbenchmark(sample_1 |> summarise(votos = sum(votos), .by=everything()[! everything() %in% c('votos')]) |> ungroup(),
               sample_1 |> mutate(votos = sum(votos), .by=c(fecha, cod_mun, siglas)) |> distinct() |>ungroup(),
               times=1) # AUMENTAR A 100 EN LA EJECUCCIÓN FINAL DE LAS DIAPOS
```

```{r}
rm(sample_1)
```

De acuerdo a la simulación realizada, se concluye que la función summarise permite realizar el desarrollo en un tiempo menor.

```{r}
#| echo: true
datos_elecciones <- datos_elecciones |>
  summarise(votos = sum(votos), .by=everything()[! everything() %in% c('votos')])
```

```{r}
#| echo: false
datos_elecciones <- datos_elecciones |>
  mutate(siglas = fct_reorder(siglas, votos, .fun = sum),
         fecha = factor(fecha, ordered = TRUE))

```

## LIMPIEZA DE DATOS

Se crea un dataset con información a nivel municipio con el identificador de este y datos de censo electoral, número de mesas electorales y participación para cada fecha.

```{r}
datos_elecciones_maestra <- datos_elecciones |> distinct(fecha, cod_mun, numero_mesas, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |> 
  mutate(votos = votos_blancos + votos_nulos + votos_candidaturas,
         p_votos = votos / censo,
         p_votos_blancos = votos_blancos / censo,
         p_votos_nulos = votos_nulos / censo,
         p_votos_candidaturas = votos_candidaturas / censo,
         p_participacion_1 = participacion_1 / censo,
         p_participacion_2 = participacion_2 / censo)
```

Para algunas variables numéricas se hace una trasformación logarítma debido a su gran dispersión. Las variables calculadas en porcentajes tiene valores extremos que en realidad son datos incoherentes (mayor número de votos que censados).

```{r}
#| warning: false
datos_elecciones_maestra |> select(where(is.numeric)) |> 
  mutate(log_censo = log(censo),
         log_numero_mesas = log(numero_mesas),
         log_participacion_1 = log(participacion_1),
         log_participacion_2 = log(participacion_2),
         log_votos = log(votos),
         log_votos_nulos = log(votos_nulos),
         log_votos_blancos = log(votos_blancos),
         log_votos_candidaturas = log(votos_candidaturas)) |> 
  select(matches("p_|log_")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(x=value)) +
  tema_7 +
  geom_density() +
  facet_wrap(.~name, scales = "free")
```

## Limpieza de datos

También se encuentran datos de participación erróneos como:

-   Datos de participación mayores a 1.\
-   Datos del primer avance superiores al segundo avances / datos del primer avance superior a 1.\
-   Datos del segundo avance a cero.

En la primera casuística, eliminamos los registros donde el número de votos es superior al número de censados. (solo dos registros)

```{r}
#| code-fold: true
datos_elecciones_maestra <- datos_elecciones_maestra |> 
  anti_join(datos_elecciones_maestra |> 
              filter(p_votos>1), by=c("fecha","cod_mun") )
```

Los casos donde tanto el primer como el segundo avance es cero, se dan por válidos ya que el censo electoral de esos municipios es muy pequeño (vamos a suponer que todos los censados del pueblo fueron a votar a última hora).

```{r}
#| echo: true
datos_elecciones_maestra |> 
  filter(p_participacion_1 == 0 & p_participacion_2 == 0 ) |> 
  select(fecha, cod_mun, censo, p_participacion_1, p_participacion_2, p_votos)
```

## Limpieza de datos

En los casos donde el dato del primer avance es superior al segundo se buscan municipios similares a él y se sustituye su dato de participación por la media de estos municipios similares. Hacemos el mismo trabajo para casos donde el dato del primer avance es superior a uno.

```{r}
#| echo: true
datos_elecciones_maestra |> 
  filter(p_participacion_1 > 1 | p_participacion_1 > p_participacion_2) |> 
  select(fecha, cod_mun, censo, p_participacion_1, p_participacion_2)
```

\newpage

## Limpieza de datos

1.  Declaración de la función:

```{r}
#| echo: true
#| code-fold: true

correcion_df <- function(data, cond_errata){
  a <- data |> filter( eval(parse(text=cond_errata)) )
  
  return(as_tibble(a))
}

correcion_dato_censal <- function(data, var_errata, fecha_errata, mun_errata){
  
  censo_errata <- data |> 
    filter(fecha==fecha_errata & cod_mun == mun_errata) |> 
    select(censo) |> 
    pull()
  
  part_2_tope <- data |> 
    filter(fecha==fecha_errata & cod_mun == mun_errata) |> 
    select(p_participacion_2) |> 
    pull()
  
  varlor_new <- data |> 
    filter(fecha == fecha_errata & cod_mun != mun_errata & eval(parse(text=var_errata)) <= 1 & p_participacion_2 <= part_2_tope) |>
    filter(between(censo,
                   censo_errata - censo_errata * 0.1,
                   censo_errata + censo_errata * 0.1)) |> 
    select(all_of(var_errata)) |> 
    sapply(, FUN = "mean", na.rm = TRUE)
  
  if (is.na(varlor_new)) { varlor_new = part_2_tope}
  if (varlor_new > part_2_tope) { varlor_new = part_2_tope}
  # print de validación
  # print(data |> filter(fecha==fecha_errata & cod_mun!=mun_errata & eval(parse(text=var_errata))<=1) |>
  #         filter(between(censo,
  #                        censo_errata-censo_errata*0.10,
  #                        censo_errata+censo_errata*0.10)) |> select(fecha,cod_mun,censo,var_errata) |> 
  #         mutate(val1=censo_errata-censo_errata*0.10,val2=censo_errata+censo_errata*0.10))
  
  return(varlor_new)
}
```

2.  Aplicación de la función:

```{r}
#| echo: true
#| code-fold: true

cond_errata_1 = "(p_participacion_1>1 | p_participacion_1>p_participacion_2)"

new_data <- 
correcion_df(datos_elecciones_maestra,cond_errata_1) |>
  mutate(p_participacion_1 = correcion_dato_censal(data = datos_elecciones_maestra, # corrijo con la base de datos original
                                                   var_errata = "p_participacion_1",
                                                   fecha_errata = fecha,
                                                   mun_errata = cod_mun),
         .by = c(fecha, cod_mun))
```

3.  Corrección de base de datos original:

```{r}
#| echo: true
#| code-fold: true
datos_elecciones_maestra <- datos_elecciones_maestra |> 
  anti_join(new_data, by = c("fecha", "cod_mun"))
datos_elecciones_maestra <- rbind(datos_elecciones_maestra, new_data)
```

4.  Comprobación de registros con la base obtenida.

```{r}
#| echo: true
#| code-fold: true
datos_elecciones_maestra <- datos_elecciones_maestra |> 
  anti_join(new_data, by=c("fecha", "cod_mun"))

datos_elecciones_maestra <- rbind(datos_elecciones_maestra,new_data)

datos_elecciones_maestra |> 
  filter(p_participacion_1>1 | p_participacion_1 > p_participacion_2) |> 
  select(fecha, cod_mun, censo, p_participacion_1, p_participacion_2)
```

```{r}
#| echo: true
#| code-fold: true
datos_elecciones_maestra |> 
  filter(p_participacion_1 != 0 & p_participacion_2 == 0 ) |> 
  select(fecha, cod_mun, censo, p_participacion_1, p_participacion_2, p_votos)
```

## Limpieza de datos

5.  Resultado.

```{r}
#| echo: true
#| code-fold: true

datos_elecciones_maestra |> 
  filter(p_participacion_1==0 & p_participacion_2 == 0) |> 
  select(fecha, cod_mun, censo, p_participacion_1, p_participacion_2, p_votos)
```

```{r}
datos_elecciones_maestra |> 
  select(where(is.numeric)) |> 
  mutate(log_censo = log(censo),
         log_numero_mesas = log(numero_mesas),
         log_participacion_1 = log(participacion_1),
         log_participacion_2 = log(participacion_2),
         log_votos = log(votos),
         log_votos_nulos = log(votos_nulos),
         log_votos_blancos = log(votos_blancos),
         log_votos_candidaturas = log(votos_candidaturas)) |> 
  select(matches("p_|log_")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(x = value)) +
  tema_7 +
  geom_density() +
  facet_wrap(.~name, scales = "free")
```

## ENCUESTAS

-   Filtros.

    -   Hagan referencia a elecciones anteriores a 2.008.
    -   Sean a pie de urna.
    -   Tengan un tamaño muestral inferior a 750 o que sea desconocido.
    -   Tengan menos de 1 o menos días de trabajo de campo.

```{r}
encuestas <- encuestas |>  filter(!date_elec<"2008-01-01" & # descarto que hagan referencia a elecciones anteriores a 2008
                                    !exit_poll & # descarto que sean a pie de urna
                                    (size >= 750 & !is.na(size)) & # descarto que tenga un tamaño muestral inferior a 750 o que sea desconocido
                                    (field_date_to-field_date_from) > 1# descarto que tengan menos de 1 o menos días de trabajo de campo
                                    )

```

-   Datos eliminados.
    -   Columnas con valor único.
    -   Columnas sin valores informados. (partidos políticos con toda la información a NA)
    -   Se eliminan las columnas: `r cols_sin_informacion`.

```{r}
cols_sin_informacion <- encuestas |> 
  summarise(across(everything(), n_distinct)) |>  
  pivot_longer(cols = everything()) |>  
  filter(value==1) |>  
  select(name) |>  
  pull()

encuestas <- encuestas |>  
  select(-all_of(cols_sin_informacion))
```

-   Se transforma la base de datos encuestas a formato tidy.

```{r}
encuestas <- encuestas |>
  pivot_longer(cols = -("date_elec":"turnout"),
               names_to = "partido_politico",
               values_to = "estimacion_votos") |> 
  drop_na(estimacion_votos)
```

-   Normalizamos los nombre de los partidos de manera análoga a la base de datos de votaciones.

```{r}
encuestas <- encuestas |> 
  mutate(siglas = case_when(str_detect(str_to_lower(partido_politico), ".*part.*popul|pp") ~ "PP",
                          # P.P-E.U. nos interesa como PP
                          # listas conjuntas con el Partido Popular en las elecciones municipales y autonómicas de 2007
                          # en las elecciones generales de 2011 se presentó en coalición con el Partido Popular
                          str_detect(str_to_lower(partido_politico), "^part.*socialist|^socialist.*teruel|psoe") ~ "PSOE",
                          str_detect(str_to_lower(partido_politico), "^ciudadanos.*partido|^ciutadans|cs") ~ "C's",
                          str_detect(str_to_lower(partido_politico), "vasco|eaj-pnv") ~ "PNV",
                          str_detect(str_to_lower(partido_politico), "galego|bng") ~ "BNG",
                          str_detect(str_to_lower(partido_politico), "comprom") &
                            !str_detect(partido_politico,"^0-9")~ "COMPROMÍS", # para evitar COMPROMÍS 2
                          str_detect(str_to_lower(partido_politico), "^conver.*uni|^conver.*cata|ciu") ~ "CiU",
                          # El 19 de septiembre de 1978 [Convergencia Democrática de Cataluña] se coalizó con Unió Democràtica de Catalunya
                          # El 18 de junio de 2015 Convergència Democràtica de Catalunya anunció el fin de Convergència i Unió 
                          str_detect(str_to_upper(partido_politico), "VERDES|PODEM|EZKER|COMUNISTA|ZQUIERDA REPUBLICANA
                                     |VERDS|IZQUIERDA UNIDA|EN MAREA|UNIDAD POPULAR|EQUO")  # importante que el | esté en esta línea y no al final de la anterior
                            ~ "UP",
                          partido_politico == "UP" ~ "UP",
                          partido_politico == "IU" ~ "UP",
                          str_detect(str_to_lower(partido_politico), "erc") |
                            str_detect(tolower(partido_politico), "esquerra republicana") ~ "ERC",
                          # FRONT PEL PAIS VALENCIA-ERC --> ERC
                          # https://www.vilaweb.cat/noticia/1142933/20000710/front-pais-valencia-fusionara-erc.pdf
                          str_detect(str_to_upper(partido_politico), "EH|EUSKO|ARALAR") | 
                            str_detect(str_to_upper(partido_politico), "EH|EUSKO|ARALAR|EH-BILDU") ~ "EH - BILDU",
                          str_detect(str_to_upper(stringi::stri_trans_general(partido_politico, id = "Latin-ASCII")), "MAS PAIS|MP") ~ "MÁS PAÍS",
                          str_detect(str_to_upper(partido_politico), "VOX") ~ "VOX",
                          TRUE ~ "Otros")) 

encuestas <- encuestas |> 
  mutate(siglas = factor(siglas, levels = c("BNG","C's","CiU","COMPROMÍS","EH - BILDU","ERC",
                                                  "MÁS PAÍS","PNV","PP", "PSOE","UP","VOX", "Otros")))
```

# ANÁLISIS DE VOTACIONES

Los datasets finales con los que trabajaremos en el análisis son encuestas y datos_elecciones, que son dos tibbles y están en formato tidy, lo que nos ayudará a realizar los análisis correspondientes. Se eligió este formato por las siguientes razones:

-   Los nombres de las columnas de un tibble hacen que los datos sean más fáciles de entender.

-   Los tipos de datos específicos de los valores de un tibble ayudan a prevenir errores, con los que se trabaja en el análisis son adecuados para el estudio propuesto.

-   Permiten el uso de pipes y tidyverse.

\newpage

## Análisis de votaciones

Los datasets que contienen los datos necesarios para analizar la evolución de la opinión pública en España desde 2.008 son: **encuestas** tibble de dimensión [13379\*10]{.underline} y **datos_elecciones**, tibble de dimensión [367241\*13]{.underline}.

Además las siglas las hemos definido de acuerdo a las indicaciones señaladas, excluyendo la base de datos "siglas" debido a no tener datos completos para el presente estudio, considerando que no abarca todos los partidos politicos que sugiere el proyecto.

Tampoco necesitamos el dataset cod_mun ya que hemos añadido su información a datos_elecciones.

```{r}
#| collapse: true
head(encuestas)
```

```{r}
#| collapse: true
head(datos_elecciones)
```

## Análisis de votaciones

El análisis es principalmente a través de dataviz y con información de los partidos políticos. Definimos los colores con los que vamos a representar a cada uno de los partidos.

```{r}
#| echo: true
#| code-fold: true

#Colocación de colores para cada sigla según su color oficial
datos_elecciones <- datos_elecciones |>
  mutate(color_politico = case_when(siglas == "PP" ~ "#3399FF",
                         siglas == "PSOE" ~ "#F6350B",
                         siglas == "C's" ~ "#FF5824",
                         siglas == "PNV" ~ "#008135",
                         siglas == "BNG" ~ "#76b3dd",
                         siglas == "COMPROMÍS" ~ "#de6c25",
                         siglas == "CiU" ~ "#FF0000",
                         siglas == "UP" ~ "#6D50B3",
                         siglas == "ERC" ~ "#ffbf41",
                         siglas == "EH - BILDU" ~ "#00bda1",
                         siglas == "MÁS PAÍS" ~ "#E61455",
                         siglas == "VOX" ~ "#73B446",
                         TRUE ~ "#462B25"))

#Generación de tibble con colores para cada sigla según su color oficial
colores_politicos <- datos_elecciones |> 
  distinct(siglas) |> 
  mutate(color_politico=case_when(siglas == "BNG" ~ "#76b3dd",
                                  siglas == "C's" ~ "#FF5824",
                                  siglas == "CiU" ~ "#FF0000",
                                  siglas == "COMPROMÍS" ~ "#de6c25",
                                  siglas == "EH - BILDU" ~ "#00bda1",
                                  siglas == "ERC" ~ "#ffbf41",
                                  siglas == "MÁS PAÍS" ~ "#E61455",
                                  siglas == "PNV" ~ "#008135",
                                  siglas == "PP" ~ "#3399FF",
                                  siglas == "PSOE" ~ "#F6350B",
                                  siglas == "UP" ~ "#6D50B3",
                                  siglas == "VOX" ~ "#73B446",
                                  TRUE ~ "#462B25"))


cols <- rlang::set_names(colores_politicos$color_politico, 
                         colores_politicos$siglas)

```

```{r}
#Cálculo de número de elecciones
n_elecc <- datos_elecciones |> 
  distinct(fecha) |> 
  pull() |> 
  length()
```

```{r}
#| echo: true
#| code-fold: true
# Censo total en cada elección
maestra_censo <- datos_elecciones |> distinct(fecha, cod_mun, censo) |> summarise(censo=sum(censo), .by = fecha)

# Total de votos por sigla en cada uno de las fechas (agupamos todos los votos de todos los municipios)
data_1 <- datos_elecciones |>
  summarise(votos=sum(votos), .by = c(fecha, siglas, color_politico)) |> 
  left_join(maestra_censo, by = "fecha")
  # left_join(datos_elecciones |> distinct(fecha, cod_mun, censo) |> summarise(censo=sum(censo), .by = fecha), by = "fecha")

min_votos <- data_1 |> summarise(votos=sum(votos), .by=fecha) |> 
  summarise(min_v=min(votos)) |> pull()

participacion <- data_1 |> summarise(participacion=sum(votos)/max(censo), .by=fecha)

p_votos <- data_1 |> summarise(votos = sum(votos), .by=fecha) |> left_join(maestra_censo, by = "fecha") |> 
  mutate(p_votos = votos/censo) |> select(p_votos) |> pull()
```

# Análisis de votaciones en España en el rango 2008 - 2019

En España se han realizado `r n_elecc` votaciones en el rango de años de 2.008 a 2.019. Para analizar estas votaciones, se utilizaron **datos electorales** y de participación y número de votos. Se utilizaron las **encuestas electorales** desde 2.008 incluyendo sus casas encuestadoras, la fecha de las futuras elecciones y el tipo de encuesta.

# Participación

El número de votos siempre se ha mantenido por encima de `r format(min_votos, scientific=FALSE)` votos pero, ¿cuánto ha supuesto este número de votos sobre el total de la población?

Comparando la participación con el censo para cada una de las elecciones:

```{r}
data_1 |> 
  summarise(votos = sum(votos), .by = c(fecha, censo)) |> 
  mutate(p_votos = votos/censo) |> 
  ggplot(aes(x = fecha)) +
  geom_col(aes(y = censo)) +
  tema_7 +
  geom_hline(yintercept = mean(participacion$participacion)*(1/0.00000003), 
             linetype = "dashed", color = "white", linewidth = 0.5) +
  geom_line(aes(y = p_votos*(1/0.00000003)), group = 1, color = "#e3005a") +
  scale_y_continuous(name = "Número de votos", sec.axis = sec_axis(~.*0.00000003, name = "Participación (%)")) +
  scale_y_break(c(500000, 20000000)) +
  labs(
    title = "Participación por número de votos y fecha",
    x = "Fecha de elección"
  )
```

El número de censados aumenta y la participación parece que va a la baja, aunque con seis evaluaciones no se puede afirmar con seguridad. Al comienzo de 2019 hay un repunte de la participación, pero de nuevo vuelve a bajar, posiblemente por el "aburrimiento" de volver a votar en ese mismo año.

## Peso de no votantes versus el total de votos

Miramos el peso que han tenido las personas censadas que no han votado versus el total de votos por cada una de las elecciones.

```{r}
gif_image <- image_read("https://raw.githubusercontent.com/MarioC0093/Software_GRUPAL_7/main/Versiones%20finales/imagenes/votar.gif") |>  image_scale("150")

fig <- image_graph(width = 300, height = 400)
fig <- image_graph()

data_1 |> summarise(votos=sum(votos),.by=c(fecha, censo)) |> mutate(no_votos=censo-votos) |>
  pivot_longer(cols = c(votos, no_votos), names_to = "tipo_voto") |> 
  ggplot() +
  geom_col(aes(x=fecha, y=value, fill=tipo_voto), position = "fill")+
  tema_7 +
  labs(title = "Porcentaje de participación respecto al censo electoral",
       x = "Fecha elección",
       y = "Valor relativo")


# Composing the full image
# out <- image_composite(fig, gif_image, offset = "+00+100",  gravity = "center")
out <- image_composite(fig, gif_image, offset = "+120+75",  gravity = "southeast")


# Animation of the image
animation <- image_animate(out, fps = 10, optimize = TRUE)

# Show the image
print(animation, info = FALSE) 
```

## Peso de no votantes versus el total de votos

Al igual que al inicio veíamos los votos recibidos por cada partida, ahora incluímos ese *no voto* como una representatividad más.

```{r}
# ToDo: reordenar los factores para que no_votos salga arriba del todo
data1_new <- 
data_1 |> summarise(votos=sum(votos),.by=c(fecha, censo)) |> mutate(no_votos=censo-votos) |>
  pivot_longer(cols = c(votos, no_votos), names_to = "tipo_voto") |>
  filter(tipo_voto=="no_votos") |> select(fecha, siglas=tipo_voto, votos=value) |>
  rbind(data_1 |> summarise(votos=sum(votos),.by=c(fecha, siglas)))  |> 
  mutate(color_politico=case_when(siglas == "BNG" ~ "#76b3dd",
                                  siglas == "C's" ~ "#FF5824",
                                  siglas == "CiU" ~ "#FF0000",
                                  siglas == "COMPROMÍS" ~ "#de6c25",
                                  siglas == "EH - BILDU" ~ "#00bda1",
                                  siglas == "ERC" ~ "#ffbf41",
                                  siglas == "MÁS PAÍS" ~ "#E61455",
                                  siglas == "PNV" ~ "#008135",
                                  siglas == "PP" ~ "#3399FF",
                                  siglas == "PSOE" ~ "#F6350B",
                                  siglas == "UP" ~ "#6D50B3",
                                  siglas == "VOX" ~ "#73B446",
                                  siglas == "no_votos" ~ "grey",
                                  TRUE ~ "#462B25")) |> 
  mutate(siglas=fct_reorder(siglas, votos, .fun = sum))

cols_new <- rlang::set_names(data1_new$color_politico, 
                         data1_new$siglas)

data1_new |> 
  ggplot() +
  geom_col(aes(x=fecha, y=votos, fill=siglas), position = "fill") +
  scale_fill_manual(values = cols_new) +
  tema_7 +
  labs(
    title = "Proporción de votos por partido político por elección",
    x = "Fecha de elección",
    y = "Proporción de votos"
  )
  

# rm(data_1)
```

## Peso de no votantes versus el total de votos

```{r}
datos_porcentaje_voto <- datos_elecciones |> distinct(fecha,cod_mun,municipio,codigo_ccaa,censo,votos_blancos,votos_nulos,votos_candidaturas) |>
  mutate(votos_municipio = votos_blancos + votos_nulos + votos_candidaturas,
         p_votos_blancos = round(votos_blancos/censo,2),
         p_votos_nulos = round(votos_nulos/censo,2),
         p_votos_candidaturas = round(votos_candidaturas/censo,2),
         p_voto = round(votos_municipio/censo,2))
```

```{r}
# Esto es para ver que las tendencias de votos en blanco y votos nulos no son las mismas en cuestión del censo. Aunque me genera la duda si en el gráfico anterior también tengo que hacer el summarise
# Entiendo que no porque al hacer el geom_col él mismo te hace la media, y el geom_point como estás mostrando un punto por cada registro sí que es necesario hacer la media para que no salgan varios puntos uno encima del otro en el mismo cuantil.
datos_porcentaje_voto |> mutate(censo_quantile = factor(ntile(censo , 20))) |> 
  select(fecha, censo_quantile, p_votos_blancos, p_votos_nulos, p_voto) |> 
  summarise(p_votos_blancos = mean(p_votos_blancos),
            p_votos_nulos = mean(p_votos_nulos),
            p_voto = mean(p_voto),
            .by = c(fecha, censo_quantile)) |>
  pivot_longer(cols = p_votos_blancos:p_votos_nulos,
               values_to = "porcentaje") |> 
  ggplot(aes(x=censo_quantile, y=porcentaje, color = name, group = name))+
  tema_7 +
  geom_line()+
  geom_point()+
  facet_wrap(~fecha)+
  scale_color_manual(values = colores)+
  labs(title = "Distribución de votos blancos y nulos", 
       x = "Censo electoral en deciles",
       y = "Porcentaje absoluto",
       color = "Leyenda")
```

## Distribución de votos

::: columns
::: {.column width="50%"}
España cuenta en la actualidad con 6 partidos políticos de corte nacional, y 6 partidos políticos de estatus autonómico o nacionalista. Su concentración de voto en cada una de las elecciones se pueden apreciar en el siguiente gráfico.
:::

::: {.column width="50%"}
Hasta el 2.011 la dominancia de los partidos de corte nacional fue superior al 80 %, disminuyó entre las votaciones del 2.015 a abril del 2.019 a valores del 71 % - 75 %, y en la siguiente votación volvió a aumentar al 78 %.
:::
:::

```{r}
siglas_aut_y_nac <- function(data){
  data <- data |> mutate(corte_partido = if_else(siglas %in% c("PSOE","PP","VOX","CS","MP","UP"),
                                           "Nacional", "Autonómico/Nacionalista"))
  return(data)
}

datos_elecciones <- siglas_aut_y_nac(datos_elecciones)

pr1 <- datos_elecciones |> 
  summarise(suma = sum(votos), .by = c(corte_partido, fecha)) |> 
  mutate(prop = round(suma/(sum(suma)),2), .by = c(fecha))

pr1 |> 
  group_by(corte_partido) |> 
  ggplot(aes(x = fecha, y = prop, fill = corte_partido)) +
  geom_col(position = "fill") + 
  geom_text(aes(label = percent(prop)), 
            format = "%.0f%%", position = position_fill(0.5)) +
  scale_fill_manual(values = colores) +
  tema_7 + 
  theme(legend.position = "bottom") +
  labs(
    title = "Porcentaje de votos nacionales y autonómicos por elección",
    x = "Fecha elección",
    y = "Proporción de votos",
    fill = "Partidos")
```

## Votaciones en municipios con mayor censo

```{r}
#| include: false
mun_100000 <- datos_elecciones |> filter(censo > 100000) |> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=1, by=c(fecha, cod_mun)) |> select(cod_mun) |> n_distinct()
```

Se trata de `r mun_100000` municipios con más de 100.000 censados.

Vemos la distribucion del total de votos en estos municipios en cada una de las elecciones.

El peso de los partidos de ámbito nacional se mantiene.

```{r}
pr1 <- datos_elecciones |> 
  filter(censo > 100000) |> 
  summarise(suma = sum(votos), .by = c(corte_partido, fecha)) |> 
  mutate(prop = round(suma/(sum(suma)),2), .by = c(fecha))

pr1 |> 
  group_by(corte_partido) |> 
  ggplot(aes(x = fecha, y = prop, fill = corte_partido)) +
  geom_col(position = "fill") + 
  geom_text(aes(label = percent(prop)), 
            format = "%.0f%%", position = position_fill(0.5)) +
  scale_fill_manual(values = colores) +
  tema_7 + 
  theme(legend.position = "bottom") +
  labs(
    title = "Porcentaje de votos nacionales y autonómicos por elección ",
    caption = "Solo considerando municipios con más de 100.000 habitantes.",
    x = "Fecha elección",
    y = "Proporción de votos",
    fill = "Partidos")
```

## Votaciones en municipios con mayor censo

Misma representación para los `r mun_100000` municipios con más de 100.000 censados pero a nivel de partido político y no en función del ámbito.

```{r}
pr2 <- datos_elecciones |> 
  filter(censo > 100000) |> 
  summarise(suma = sum(votos), .by=c(fecha,siglas)) |> 
  mutate(prop = round(suma/(sum(suma)),2), .by=c(fecha))
```

::: columns
::: {.column width="70%"}
```{r}


# cols <- rlang::set_names(colores_politicos$color_politico, 
#                          colores_politicos$siglas)

pr2 |> 
  ggplot() +
  geom_col(aes(x = fecha, y = prop, fill = siglas), 
           position = "fill", alpha = 0.9) + 
  #geom_text(aes(label = (prop*100)), position = position_fill(0.5)) +
  tema_7 + 
  scale_fill_manual(values = cols) +
  theme(legend.position = "right") +
  labs(
    title = "Proporción de votos en cada elección por partido",
    caption = "Solo considerando municipios con más de 100.000 habitantes.",
    x = "Fecha de elección",
    y = "Proporción de votos",
    fill = "Partido político"
  )
```
:::

::: {.column width="30%"}
Proporción de votos del partido más votado en estos municipios en cada fecha.

```{r}
pr2 |> arrange(fecha, -prop) |> group_by(fecha) |> slice_max(prop, n=1) |> select(fecha, siglas, prop)
```
:::
:::

## Partido ganador por elección

::: columns
::: {.column width="50%"}
-   Bajamos ahora a nivel municipio para ver el primer y segundo partido más votado.
    -   No excluímos a ningún municipio en función del censo.
-   Visualmente.
    -   Se aprecia que cuando el PP queda en primer lugar el partido que más veces está en segundo puesto es el PSOE. Y viceversa.

```{r}
#| collapse: true
datos_elecciones|> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=2, by=c(fecha, cod_mun)) |> select(fecha, cod_mun, siglas, votos)

# Partido más votado
mas_votado1 <- 
datos_elecciones |> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=2, by=c(fecha, cod_mun), with_ties = TRUE) |> select(fecha, cod_mun, codigo_ccaa, siglas, votos) |> 
  slice_max(votos, n=1, by=c(fecha, cod_mun), with_ties = TRUE) |> mutate(posicion = "Más votado")

# Segundo partido más votado
mas_votado2 <- 
datos_elecciones |> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=2, by=c(fecha, cod_mun), with_ties = TRUE) |> select(fecha, cod_mun, codigo_ccaa, siglas, votos) |> 
  slice_min(votos, n=1, by=c(fecha, cod_mun), with_ties = TRUE) |> mutate(posicion = "Segundo más votado")

mas_votado <- rbind(mas_votado1,mas_votado2) |> arrange(fecha, cod_mun, -votos) 
```
:::

::: {.column width="50%"}
-   No tenemos manera de deshacer un empate de votos.

    -   Permitimos tener más de un partido en primera posición.
    -   Todos los partidos que estén en primera posición ocuparán tanto el primer como el segundo puesto.

```{r}
mas_votado1 |> filter(fecha=="2015-12" & cod_mun=="07-19-010")
```

```{r}
mas_votado2 |> filter(fecha=="2015-12" & cod_mun=="07-19-010")
```
:::
:::

## Partido ganador por elección

Vemos la relación entre el partido más votado y el segundo, teniendo en cuenta todos los municipios para todas las elecciones. Visualmente se aprecia que cuando el PP queda en primer lugar el partido que más veces está en segundo puesto es el PSOE. Y viceversa. Cuando el PSOE ocupa la primera posición en votos el partido que más veces está tras él es el PP.

```{r}
mas_votado1 |> select(fecha, cod_mun, siglas, posicion) |>
  left_join(mas_votado2 |> select(fecha, cod_mun, siglas, posicion),
            by=c("fecha","cod_mun"), suffix = c("_primero","_segundo")) |> 
  make_long("siglas_primero","siglas_segundo") |> 
  ggplot(aes(x = x, 
             next_x = next_x, 
             node = node, 
             next_node = next_node,
             fill = factor(node),
             label = node)) +
  tema_7 +
  scale_fill_manual(values = cols) +
  geom_sankey(flow.alpha = 0.5, node.color = 1) +
  geom_sankey_text(size = 3.5)+
  geom_sankey_label(size = 3.5, color = 1, fill = "white") +
  theme(legend.position = "none") +
  labs(
    title = "Relación entre el primer y segundo partido más votado",
    x = "",
    caption = "Considerando todas las elecciones y todos los municipios"
  )
```

## Partido ganador por elección

Vemos un pequeño flujo residual que va de PSOE en primera posición a PSOE en segunda posición. Esto se debe a los casos de empate en el partido más votado donde decidíamos poner a ambos partidos como primer y segundo partido más votado.

```{r}
mas_votado1 |> select(fecha, cod_mun, siglas, posicion) |> 
  filter(siglas=="PSOE") |> 
  left_join(mas_votado2 |> 
            select(fecha, cod_mun, siglas, posicion),
            by = c("fecha","cod_mun"), 
            suffix = c("_primero","_segundo")) |> 
  # make_long("siglas_primero","siglas_segundo") |> 
  make_long("siglas_segundo","siglas_primero") |> 
  ggplot(aes(x = x, 
             next_x = next_x, 
             node = node, 
             next_node = next_node,
             fill = factor(node),
             label = node))+
  geom_sankey(flow.alpha = 0.5, node.color = 1) +
  geom_sankey_text(size = 3.5)+
  geom_sankey_label(size = 3.5, color = 1, fill = "white") +
  scale_fill_manual(values = cols) +
  theme_sankey() +
  tema_7 +
  theme(legend.position = "none") +
  coord_flip(expand = FALSE) +
  labs(title = "Partidos en segunda posición cuando el PSOE ganó",
       x = "",
       y = "Número de municipios y votaciones",
       caption = "Considerando todas las elecciones y todos los municipios")
```

## Bipartidismo

Al momento de comparar la primera votación con la última reportada, podemos evidenciar que la tendencia bipartidista ha decrecido, en parte por la aparición de nuevos partidos y tendencias políticas

```{r}
#ToDo: poner el filtro de la fecha como el mínimo level de ese factor
parlamento <- datos_elecciones |> 
  filter(fecha==min(fecha)) |> 
  summarise(votos=sum(votos), .by = c(fecha, siglas, color_politico))

parlamento <- parlamento |> 
  mutate(asientos = round(350*votos/sum(votos))) |> select(-votos)

semicircle <- parliament_data(election_data = parlamento,
                              type = "semicircle", # Tipo de parlamento
                              parl_rows = 7,      # Número de filas del parlamento
                              party_seats = parlamento$asientos) # Asientos por partido

semi1 <- ggplot(semicircle, aes(x = x, y = y, colour = siglas)) +
  geom_parliament_seats() + 
  theme_ggparliament() +
  labs(title = "Elecciones de 2.008", x="", y="") +
  scale_colour_manual(values = semicircle$color_politico, 
                      limits = semicircle$siglas)+
  tema_7
semi1
```

## Bipartidismo

Al momento de comparar la primera votación con la última reportada, podemos evidenciar que la tendencia bipartidista ha decrecido, en parte por la aparición de nuevos partidos y tendencias políticas

```{r}

#ToDo: poner el filtro de la fecha como el mínimo level de ese factor
parlamento <- datos_elecciones |> 
  filter(fecha==max(fecha)) |> 
  summarise(votos=sum(votos), .by = c(fecha, siglas, color_politico))

parlamento <- parlamento |> 
  mutate(asientos = round(350*votos/sum(votos))) |> 
  select(-votos)

semicircle <- parliament_data(election_data = parlamento,
                                 type = "semicircle", # Tipo de parlamento
                                 parl_rows = 7,      # Número de filas del parlamento
                                 party_seats = parlamento$asientos) # Asientos por partido

semi2 <- ggplot(semicircle, aes(x = x, y = y, colour = siglas)) +
  geom_parliament_seats() + 
  theme_ggparliament() +
  labs(title = "Segundas elecciones de 2.019", x = "", y = "") +
  scale_colour_manual(values = semicircle$color_politico, 
                      limits = semicircle$siglas) +
  tema_7

semi2
rm(semicircle)
```

## Diferencias entre primer y segundo partido

::: columns
::: {.column width="50%"}
-   Dónde la diferencia entre el primer y el segundo partido es máxima.

-   Solo interesa municipios donde el censo sea alto: 2.000 censados en adelante.

-   En estos municipios de mayor censo sabemos que si vemos una diferencia de pocos votos es realmente un resultado ajustado, ya que no es lo mismo una diferencia de escasos votos en un municipio con pocos censados que esa misma diferencia en un municipio con muchos censados.

-   Trabajamos con medidas repetidas para un mismo municipio (un dato para cada una de las elecciones).

-   No agrupamos la información: queremos identificar municipios-fecha con la mayor diferencia en votos.0.
:::

::: {.column width="50%"}
Porcentaje de municipios con censo electoral menor a 2.000:

```{r}
datos_elecciones |> mutate(censo_menor2000 = if_else(censo<2000,1,0)) |> distinct(fecha, cod_mun, censo_menor2000)|> summarise('% municipios'=mean(censo_menor2000), .by=(fecha)) |> spread(key = fecha, value = `% municipios`)
```

Casuísticas:

```{r}
#| code-fold: true
datos_elecciones |> mutate(censo_menor2000 = if_else(censo<2000,1,0)) |> distinct(fecha, cod_mun, censo_menor2000) |> pivot_wider(names_from = fecha, values_from = censo_menor2000) |> select(-cod_mun) |> group_by_all() |> summarise(n=n()) |>  print(n = 1e3)
```
:::
:::

## Diferencias entre primer y segundo partido

**HIGHLIGHT**

El municipio de Cesuras (La Coruña) tiene datos solo para 2008-03 y 2011-11 a pesar de tener un censo y censo electoral superior a 2.000.

```{r}
datos_elecciones |> filter(cod_mun=="11-15-026") |> distinct(fecha,cod_mun,municipio,censo,votos_candidaturas)
```

Esto es debido a que en 2.013 se crea el municipio Oza-Cesuras como fusión de los municipios de Oza de los Ríos y Cesuras.

<!-- \[![Cesuras](https://raw.githubusercontent.com/MarioC0093/Software_GRUPAL_7/main/Versiones%20finales/imagenes/censo_Cesuras.JPG)\]{width=25px} -->

```{r}
#| echo: true
datos_elecciones |> filter(cod_mun=="11-15-063") |> distinct(fecha,cod_mun,municipio,censo,votos_candidaturas)

datos_elecciones |> filter(cod_mun=="11-15-902") |> distinct(fecha,cod_mun,municipio,censo,votos_candidaturas)
```

## Diferencias entre primer y segundo partido

Tenemos dos opciones:

1.  No hablar de qué municipio tuvo mayor diferencia en votos.

    -   Hablamos de qué municipio-fecha tuvo la mayor diferencia.

2.  Quedarnos con resultados de municipios que tuvieron más de 2.000 censados y luego agregar los datos a nivel municipio.

    -   Nos obliga a agrupar a nivel municipio el número de censados y la diferencia de votos (censo medio y diferencia de votos media) y hacer filtros y análisis sobre este número medio.

```{r}
mas_votado |> anti_join(datos_elecciones |> select(fecha, cod_mun, censo) |> filter(censo<2000),
                              by = c("fecha", "cod_mun")) |> 
  group_by(fecha,cod_mun) |>  mutate(lag_votos = votos - lag(votos)) |> mutate(lag_votos=-lag_votos) |> head()
```

Se opta por la primera opción.

-   Un análisis más rápido.
-   Para alterar lo menos posible los datos reales.

## Diferencias entre primer y segundo partido

Vemos la distribución de votos para los registros con censo mayor a 2.000 y la distribución de la diferencia de votos para estos mismos municipios.

```{r}
#| results: hold
# data_2 <- mas_votado |>  mutate(lag_votos = votos - lag(votos), .by = c(fecha,cod_mun)) |> mutate(lag_votos=-lag_votos) |>
#   select(c(fecha, cod_mun, codigo_ccaa, lag_votos)) |> drop_na() |> ungroup() |> 
#   anti_join(datos_elecciones |> select(fecha, cod_mun, codigo_ccaa, censo) |> filter(censo<2000),
#                                   by = c("fecha", "cod_mun")) |> left_join(datos_elecciones |> distinct(fecha, cod_mun, votos, censo))

plot1 <- datos_elecciones |> filter(censo >= 2000) |>  
  ggplot(aes(x=votos)) +
  geom_density()

plot2 <- datos_elecciones |> filter(censo >= 2000) |>  
  ggplot(aes(x=log(votos))) +
  geom_density()

data_2 <- mas_votado |>  
  mutate(lag_votos = votos - lag(votos), .by = c(fecha,cod_mun)) |> 
  mutate(lag_votos = -lag_votos) |>
  select(c(fecha, cod_mun, codigo_ccaa, lag_votos)) |> 
  drop_na() |> 
  ungroup() |> 
  anti_join(datos_elecciones |> 
              select(fecha, cod_mun, codigo_ccaa, censo) |> 
              filter(censo<2000), by = c("fecha", "cod_mun")) |> 
  left_join(datos_elecciones |> 
              distinct(fecha, cod_mun, municipio, censo))

plot3 <- data_2 |> 
  ggplot(aes(x=lag_votos)) +
  tema_7 +
  geom_density() +
  labs(y = "Densidad de votos")

plot4 <- data_2 |> 
  ggplot(aes(x=log(lag_votos)))+
  tema_7 +
  geom_density() +
  labs(y = "Densidad de votos")

grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)
```

## Diferencias entre primer y segundo partido

La distribución del logaritmo de la diferencia de votos sigue una distribución normal y mucho más visual que la distribucion original que nos permite la búsqueda de outliers.

```{r}
plot1 <- data_2 |> 
  filter(lag_votos>0) |> 
  ggplot(aes(x=log(lag_votos), y = codigo_ccaa , fill = codigo_ccaa))+
  geom_density_ridges()+
  tema_7 +
  theme(legend.position = "none") +
  labs(
    x = "Logaritmo de votos con lag",
    y = "Codigo Comunidad autónoma"
  )

plot2 <- data_2 |> filter(lag_votos>0) |> 
  ggplot(aes(y = log(lag_votos) , x = codigo_ccaa)) +
  tema_7 +
  geom_boxplot() +
  labs(
    x = "Código Comunidad autónoma",
    y = "Logaritmo de votos con lag"
  )

grid.arrange(plot1, plot2, nrow = 2)
```

## Diferencias entre primer y segundo partido

Para determinar los municipios-fecha con mayor diferencia de voto podemos medir esta diferencia de forma absoluta o de forma relativa.

-   Absoluta: máximo número en bruto en diferencia de votos.\
-   Relativa: máxima diferencia de votos medida sobre los censados electorales.

Esta segunda forma relativiza la diferencia de votos en función del tamaño de la muestra. Ya que en municipios con mayor censo se espera mayor diferencia en votos.

```{r}
data_2 |> # summarise(censo=mean(censo), lag_votos=mean(lag_votos), .by = cod_mun) |>
  ggplot(aes(x=log(censo), y=log(lag_votos)))+
  geom_point()+
  tema_7 +
  stat_smooth(method = "lm") +
  labs(
    title = "Comparación entre población votante y diferencia absoluta de votos",
       x = "Logaritmo del censo electoral",
       y = "Logaritmo de votos con lag")
```

## Diferencias entre primer y segundo partido

::: columns
::: {.column width="50%"}
En el top cinco de mayor diferencia absoluta en votos destaca el municipio 12-28-079 (Madrid).

```{r}
#| eval: true
data_diff <- data_2 |> select(fecha, cod_mun, municipio, censo, lag_votos) |> mutate(dif_votos_absoluta =  lag_votos,
                                                                                     dif_votos_relativa = round(lag_votos/censo,4))

data_diff |> select (-c(cod_mun,lag_votos,dif_votos_relativa)) |> slice_max(dif_votos_absoluta,n=5)
```

Rankin observando para cada municipio unicamente su registro con mayor diferencia de votos absoluta/relativa.

```{r}
#| eval: true
data_diff |> select (-c(cod_mun,lag_votos,dif_votos_relativa)) |> slice_max(dif_votos_absoluta, n=1, by = municipio) |> slice_max(dif_votos_absoluta, n=5)
data_diff |> select (-c(cod_mun,lag_votos,dif_votos_absoluta)) |> slice_max(dif_votos_relativa, n=1, by = municipio) |> slice_max(dif_votos_relativa, n=5)
```
:::

::: {.column width="50%"}
De los cinco casos con mayor diferencia absoluta de votos cuatro de ellos son del municipio 01-41-901 (Cañada Rosal).

```{r}
data_diff |> select (-c(cod_mun,lag_votos,dif_votos_absoluta)) |> slice_max(dif_votos_relativa,n=5)
```

Observando en cada elección el municipio con máxima diferencia en votos absoluta/relativa el ranking es el siguiente.

```{r}
#| eval: true
data_diff |> select (-c(cod_mun,lag_votos,dif_votos_relativa)) |> slice_max(dif_votos_absoluta, n=1, by = fecha)
data_diff |> select (-c(cod_mun,lag_votos,dif_votos_absoluta)) |> slice_max(dif_votos_relativa, n=1, by = fecha)
```
:::
:::

## Diferencias entre primer y segundo partido

-   Las máximas diferencias absolutas en votos pertenecen a las grandes ciudades.
-   Suele ser Madrid el municipio con la máxima diferencia, sobre todo en elecciones más antiguas (la diferencia relativa en votos ha ido reduciéndose en cada elección).
-   La diferencia relativa en votos es mayor en municipios donde el censo es más bajo.

::: columns
::: {.column width="50%"}
A mayor censo electoral el porcentaje de voto es menor, pero el porcentaje de votos nulos no parece seguir ninguna tendencia en función del censo.

```{r}
datos_porcentaje_voto <- datos_elecciones |>
  distinct(fecha,cod_mun,municipio,codigo_ccaa,censo,votos_blancos,votos_nulos,votos_candidaturas) |>
  mutate(votos_municipio = votos_blancos + votos_nulos + votos_candidaturas,
         p_votos_blancos = round(votos_blancos/censo,2),
         p_votos_nulos = round(votos_nulos/censo,2),
         p_votos_candidaturas = round(votos_candidaturas/censo,2),
         p_voto = round(votos_municipio/censo,2))

# datos_porcentaje_voto <- datos_porcentaje_voto |> left_join(mas_votado, by = c("fecha","cod_mun"))
```

```{r}
datos_porcentaje_voto |>  
    mutate(censo_quantile = ntile(censo , 10)) |> 
    summarise(p_votos_nulos=mean(p_votos_nulos),
              p_voto=mean(p_voto), .by = censo_quantile) |>
  pivot_longer(cols = c(p_voto,p_votos_nulos),
               names_to = "tipo_voto",
               values_to = "prop") |> 
  mutate(tipo_voto = factor(tipo_voto, levels = c("p_votos_nulos", "p_voto"), ordered = TRUE)) |> 
  ggplot(aes(x = censo_quantile, y = prop, fill = tipo_voto)) +
  geom_col(position = "fill") +
  scale_y_break(c(0, 0.95))+
  geom_text(aes(label = percent(prop)), 
            format = "%.0f%%", position = position_fill(0.5)) +
  scale_fill_manual(values = colores) +
  tema_7 + 
  theme(legend.position = "bottom") +
  labs(x = "Censo electoral en deciles",
       y = "Porcentaje votos nulos")
```
:::

::: {.column width="50%"}
-   La mayor frecuencia absoluta de votos nulos la encontramos en Madrid y Barcelona (porcentaje de votos nulos casi inexistente)

```{r}
datos_porcentaje_voto |> 
  select(fecha, cod_mun, municipio, censo, votos_nulos, p_votos_nulos) |> 
  slice_max(votos_nulos, n=5)
```

-   La mayor frecuencia relativa de votos nulos la vemos en municipios con muy poco censo electoral.

```{r}
datos_porcentaje_voto |> select(fecha, cod_mun, municipio, censo, votos_nulos, p_votos_nulos) |> slice_max(p_votos_nulos, n=5)
```
:::
:::

## Nivel de participación y favorecidos

Vemos la distribución censal por cuantil y el porcentaje medio de participación, dividido por el porcentaje de votos a las candidaturas, de votos en blanco y de votos nulos (porcentajes medidos como votos -de esas tres categorías- sobre el censo).

La participación baja según aumenta el censo en las poblaciones, pero el porcentaje de votos nulos no sigue esa distribución.

```{r}
datos_porcentaje_voto |> mutate(censo_quantile = factor(ntile(censo , 10))) |> 
  select(fecha, censo_quantile, p_votos_blancos, p_votos_nulos, p_votos_candidaturas, p_voto) |> 
  summarise(p_votos_blancos = mean(p_votos_blancos),
            p_votos_nulos = mean(p_votos_nulos),
            p_votos_candidaturas = mean(p_votos_candidaturas),
            p_voto = mean(p_voto),
            .by = c(fecha, censo_quantile)) |>
  pivot_longer(cols = p_votos_blancos:p_votos_candidaturas,
               values_to = "porcentaje") |>
  mutate(name=factor(name, levels = c("p_votos_nulos","p_votos_blancos","p_votos_candidaturas"), ordered = TRUE)) |> 
  ggplot(aes(x=censo_quantile, y=porcentaje, fill=name),  alpha = 0.8)+
  tema_7 +
  geom_col(position = "fill")+
  scale_y_break(c(0, 0.95))+
  facet_wrap(~fecha)+
  scale_fill_manual(values = colores)+
  theme(legend.position = "bottom") +
  labs(title = "Distribución de votos por elección", 
       x = "Censo electoral en deciles",
       y = "Porcentaje relativo",
       fill = "Leyenda")
```

## Nivel de participación y favorecidos

```{r}
datos_porcentaje_voto |> select(fecha, cod_mun, codigo_ccaa, censo, votos_candidaturas, p_voto) |> 
  mutate(censo_quantile = ntile(censo , 20)) |> 
  left_join(mas_votado1 |> 
              select(fecha, cod_mun,siglas)) |> 
  mutate(siglas2 = if_else(siglas %in% c("PSOE","PP","VOX","CS","MP","UP"),
                           "part. principales", "part. aut./nac.")) |> 
  ggplot() +
  geom_bar(aes(x=censo_quantile, fill = siglas))+
  facet_wrap(~codigo_ccaa, scales = "free_y")+
  scale_fill_manual(values = cols) +
  tema_7 +
  labs(title = "Distribución de votos según Comunidad autónoma",
       x = "Censo en 20 quintiles",
       y = "Conteo de municipios",
       fill = "Siglas partido")
```

## Nivel de participación y favorecidos

Se aprecia que en las comunidades 09, 13 y 14 la distribución de votos se la llevan partidos políticos que no responden al bipartidismo

```{r}
datos_porcentaje_voto |> select(fecha, cod_mun, codigo_ccaa, censo, votos_candidaturas, p_voto) |> 
  mutate(censo_quantile = ntile(censo , 20), .by=codigo_ccaa) |> 
  left_join(mas_votado1 |> 
              select(fecha, cod_mun,siglas)) |> 
  mutate(siglas2 = if_else(siglas %in% c("PSOE","PP","VOX","CS","MP","UP"),
                                           "part. principales", "part. aut./nac.")) |> 
  ggplot() +
  geom_bar(aes(x=censo_quantile, fill = siglas))+
  facet_wrap(~codigo_ccaa, scales = "free_y")+
  scale_fill_manual(values = cols) +
  tema_7 +
  labs(title = "Distribución de votos según Comunidad autónoma",
       x = "Censo en 20 quintiles",
       y = "Conteo de municipios",
       fill = "Siglas partido")
```

## Nivel de participación y favorecidos

En las elecciones se suele especular con que si una alta/baja participación a cierre de urnas o en alguno de los avances favorece a unos bloques políticos u otros. Analizaremos para cada elección los resultados y niveles de participación en cada municipio.

```{r}
# lo suyo sería tener un dataset con un distinct de fecha:votos_candidaturas pero no me da tiempo
# como pte
datos_participacion_fecha_municipio <- datos_elecciones |> 
  distinct(fecha, cod_mun, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |> 
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |>
  mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(fecha, siglas_ganador)) |> 
    mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)
# recordemos que tenemos "duplicados" por los empates en el primer puesto

datos_participacion_municipio <- datos_elecciones |> 
  distinct(fecha, cod_mun, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |> 
  mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |>
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(cod_mun, siglas_ganador)) |> # aquí siglas_ganador es necesario porque a veces tenemos dos ganadores en un municipio-fecha, sino sería c(cod_mun, fecha)
  mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)|>
  summarise(censo=mean(censo),
            p_votos=mean(p_votos),
            p_participacion_1=mean(p_participacion_1),
            p_participacion_2=mean(p_participacion_2), .by=c(siglas_ganador))



# ORDENAR FACTOR siglas_ganador POR p_votos PARA QUE EL EJE Y SALGA ORDENADO
# aquí vemos para las elecciones en que gana cada partido político, cuál es la media de participación (votos),
# de participación_1 y participación_2, ponerlo en los títulos
# ¿Se ve claro así?
datos_participacion_municipio |> 
  mutate(siglas_ganador = fct_reorder(siglas_ganador, p_votos)) |> 
  ggplot(aes(y=siglas_ganador))+
  geom_line(aes(x = p_votos*(1/0.00000003)),group=1, color = "red")+
  geom_point(aes(x = p_participacion_1*(1/0.00000003)),group=2, color = "blue")+
  geom_point(aes(x = p_participacion_2*(1/0.00000003)),group=2, color = "green") +
  tema_7 +
  labs(title = "Participación por bloque horario según partido ganador",
       x = "Participación de votantes",
       y = "Partido ganador")
```

# Encuestas

Desde 2008 a 2019 se han realizado `r encuestas |> distinct(pollster) |> nrow()` encuestas, con valores muestrales que van desde `r encuestas |>  summarise(min(size)) |> pull()` a `r encuestas |>  summarise(max(size)) |> pull()` personas.

```{r}

enc01 <- encuestas |> 
  mutate(date_elec = as.Date(date_elec, format = "%Y-%m-%d")) |> 
  mutate(fecha = format(date_elec, "%Y-%m")) |> 
  group_by(fecha, siglas) |> 
  summarise(estim_voto = (mean(estimacion_votos)/100)) 

enc02 <- pr2 |> 
  left_join(enc01) |> 
  rename(Encuestas = estim_voto,
         Resultado = prop) |> 
  pivot_longer(c(Resultado, Encuestas),
    values_to = "votos",
    names_to = "origen"
  )

enc02 |> 
  ggplot() +
  geom_col(aes(x = siglas, y = votos, fill = origen), position = position_dodge()) +
  facet_wrap(~fecha) +
  coord_flip() +
  labs(
    title = "Diferencia entre estimación de encuestas y resultados",
    x = "Porcentaje de votos",
    y = "Partidos políticos",
    fill = "Fuente del dato"
  ) +
  scale_fill_manual(values = colores) +
  tema_7


```

# Encuestas

Dado que cada votación y cada encuesta presenta valores diferentes, esto las vuelve poco calibrables para los gestores de datos, se vuelve necesario hacer un análisis al detalle de cada elección para calibrar cada una de ellas.

```{r}
### Generación de boxplot

enc03 <- encuestas |> 
  mutate(date_elec = as.Date(date_elec, format = "%Y-%m-%d")) |> 
  mutate(fecha = format(date_elec, "%Y-%m")) |> 
  group_by(fecha, siglas)

enc04 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |> 
  select(fecha, siglas, prop, encuestas)

enc04 |> 
  ggplot() +
  geom_boxplot(aes(x = siglas, y = encuestas), alpha = 0.9) +
  geom_point(aes(x = siglas, y = prop), color = "red") +
  facet_wrap(~fecha, scales = "free_y") +
  coord_flip() +
  tema_7+
  labs(
    title = "Error asociado a cada encuesta",
    x = "Partidos políticos",
    y = "Error de las encuestas",
    caption = "En rojo el resultado final en esa votación"
  )

#Prueba a nivel nacional
enc04 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |> 
  select(fecha, siglas, prop, encuestas) |> 
  mutate(dif = encuestas - prop)

enc04 |> 
  ggplot() +
  geom_boxplot(aes(x = fecha, y = dif), na.rm = TRUE, alpha = 0.9) +
  #geom_point(aes(x = siglas, y = dif), color = "red") +
  coord_flip() +
  labs(
    title = "Error asociado a cada votación",
    x = "Fecha de votación",
    y = "Diferencia del valor estimado por las encuestas"
  )+
  tema_7

```

\newpage

## Encuestas menos precisas

```{r}
enc05 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |>
  ungroup() |> 
  summarise(prom_enc = round(mean(encuestas),2), .by = c(fecha, siglas)) |> 
  left_join(pr2) |> 
  mutate(dif = abs(prom_enc - prop)) |> 
  summarise(prom_dif = mean(dif, na.rm = TRUE), .by = fecha)

enc05 |> 
  ggplot() +
  geom_point(aes(x = fecha, y = prom_dif), shape = 3, size = 4) +
  tema_7 +
  labs(
    title = "Diferencias entre resultados estimados por encuestas y resultados de elecciones",
    x = "Fecha votación",
    y = "Diferencia promedio entre encuesta y resultado elección"
  )

```

Las encuestas se equivocaron más en la elección del 2011-11, seguida del 2016-06 y 2019-11. Curiosamente en las elecciones de 2019-04 el promedio de las encuestas estuvo bastante cerca del resultado final.

\newpage

## Error de encuestas en partidos de ámbito nacional

```{r}
enc06 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |> 
  select(fecha, siglas, prop, encuestas) |> 
  filter(siglas %in% c("PSOE","PP", "VOX", "CS", "MP", "UP", "IU"))

enc06 |> 
  ggplot() +
  geom_boxplot(aes(x = siglas, y = encuestas), alpha = 0.9) +
  geom_point(aes(x = siglas, y = prop), color = "red") +
  facet_wrap(~fecha, scales = "free_y") +
  coord_flip() +
  tema_7 +
  labs(
    title = "Error asociado a cada encuesta, solo partidos de ámbito nacional",
    x = "Partidos políticos",
    y = "Error de las encuestas",
    caption = "En rojo el resultado final en esa votación"
  )

```

Se evidencia que las encuestas previeron resultados disímiles respecto a los partidos de ámbito nacional, como aquellas del 2019, donde al PSOE lo subestiman en abril y luego lo sobrestiman en noviembre, caso contrario para el PP en el mismo rango.

\newpage

## Casas encuestadoras

```{r}
#| results: hold
enc07 <- encuestas |> 
  mutate(date_elec = as.Date(date_elec, format = "%Y-%m-%d")) |> 
  mutate(fecha = format(date_elec, "%Y-%m")) |> 
  group_by(fecha, siglas, id_pollster)

enc08 <- pr2 |> 
  left_join(enc07) |> 
  mutate(estimado = estimacion_votos/100) |> 
  pivot_longer(c(prop),
    values_to = "votos") |> 
  mutate(dif = abs(estimado - votos))

enc08 |> 
  ggplot() +
  geom_boxplot(aes(x = fct_rev(pollster), y = dif), na.rm = TRUE, 
               outlier.shape = 10, 
               outlier.alpha = 0.8) +
  #geom_point(aes(x = siglas, y = dif), color = "red") +
  coord_flip() +
  tema_7 +
  labs(
    title = "Error asociado a cada casa encuestadora",
    x = "Casa encuestadora",
    y = "Diferencia del valor estimado por las encuestas"
  )

```

Se puede apreciar que las casas CIS, ENCUESTAMOS y MYWORD presentan los rangos más amplios de resultados, y CELESTE-TEL la que presenta más outliers.

# FIN
