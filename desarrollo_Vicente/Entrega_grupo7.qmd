---
title: "Entrega grupo 7"
author: "Mario Camacho, Diana Cáceres, Vicente Pantoja-Maggi"
format: revealjs
html:
    theme: [style.scss]
    toc: true
    toc-location: right
    toc-title: Índice
editor: visual
---

> Introduce en el chunk inferior los paquetes que vayas a necesitar

```{r paquetes}
#| warning: false
knitr::opts_chunk$set(echo = F) #echo: false por defecto
options(scipen=999) #Para evitar el uso de notación científica para números
#rm(list = ls()) # Borramos variables de environment
# remotes::install_github("davidsjoberg/ggsankey")
# Cargar librerias
library(tidyverse)
library(skimr)
library(stringi)
library(lubridate)
library(glue)
library(ggthemes)
library(showtext)
library(ggridges)
library(ggsci)
library(dplyr)
library(scales)
library(microbenchmark)
library(gridExtra)
library(ggparliament)
library(ggsankey)
library(ggbreak)
library(magick)
library(outliers)

```

La práctica versará entorno a los **archivos de datos electorales** que ya hemos trabajado, recopilando datos de citas electorales al Congreso de los Diputados de España desde 2008 hasta 2019.

```{r}
# NO TOQUES NADA
datos_elecciones <- read_csv(file = "./datos/datos_elecciones_brutos.csv")
cod_mun <- read_csv(file = "./datos/cod_mun.csv")
encuestas <- read_csv(file = "./datos/historical_surveys.csv")
siglas <- read_csv(file = "./datos/siglas.csv")

#colores <- c("#76b3dd", "#FF0000", "#de6c25", "#FF5824", "#00bda1", "#ffbf41", "#E61455", 
#             "#008135", "#F6350B", "#6D50B3", "#73B446", "#3399FF", "gray40")

font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()

colores <- c("#e3005a","#00d3da", "#4e5dff", "#efae00", "#001352", "#b7ff6b", "#ff4526", "#260015",  "#ffeaa2", "#5dabff", "#8a8100", "#007a72", "#432500")

tema_7 <- theme_minimal() +
  theme(text = element_text(family = "Roboto"),
        plot.title = element_text(size = 18, face = "bold"),
        plot.caption = element_text(face = "italic")) 

```

# Preparación de datos

Para el desarrollo del presente trabajo, se han considerado las siguientes bases de datos:

-   `datos_elecciones`: archivo con los datos electorales al Congreso desde 2008 hasta las últimas de 2019.

-   `cod_mun`: archivo con los códigos y nombres de cada municipio

-   `siglas`: siglas y nombres asociados a cada partido

-   `encuestas`: tabla de encuestas electorales desde 1982.

## DATOS ELECCIONES

La base de datos "datos_elecciones" original es un tible de 48.737 x 471 lo que impide su comprensión para un correcto análisis de datos.

```{r}
datos_elecciones |> head()
```

Se considera que es mejor tener una columna con todos los partidos políticos y otra con el número de votos de cada uno en cada municipio en cada una de las elecciones registradas. Además se procederá a eliminar los valores NA, ya que estos registros hacen referencia a partidos que no han recibido votos en esas elecciones y no aportan información.

Como paso previo se considera eliminar aquellas columnas que no aporten información, es decir, todas aquellas que tengan un único valor.

```{r}
#| results: hold
cols_sin_informacion <- datos_elecciones |> 
  select(1:15) |>
  summarise(across(everything(), n_distinct)) |> 
  pivot_longer(cols = everything()) |> 
  filter(value==1) |> 
  select(name) |> 
  pull()

#Se genera un summary para evaluar si las columnas a eliminar efectivamente son inutiles en el análisis
datos_elecciones |>  
  select(all_of(cols_sin_informacion)) |>  
  summary() 

datos_elecciones <- datos_elecciones |> 
  select(-all_of(cols_sin_informacion))
```

\newpage

Se eliminan las columnas: `r cols_sin_informacion`.

-   *tipo_eleccion*: valor constante 02.

-   *codigo_distrito_electoral*: valor constante 0.

-   *vuelta*: valor constante 1.

Obteniendo como resultado un tibble, con menos columnas y más filas que los datos originales.

```{r}
datos_elecciones <- datos_elecciones |>
  pivot_longer(cols = -c(anno:votos_candidaturas),
               names_to = "partido_politico",
               values_to = "votos") |>
  drop_na(votos) 
```

Comprobamos que el número mínimo de votos es 1, por lo que un valor NA no significa que sea un dato faltante si no que no ha recibido ningún voto y por lo tanto tiene sentido haber eliminado los NA de la nueva columna votos.

```{r}
summary(datos_elecciones$votos)
```

\newpage

Se crea una nueva columna llamada fecha utilizando las columnas "anno" y "mes" y una nueva "id_mun" que permite unir las dos bases de datos datos_elecciones con cod_mun. Se eliminan las columnas *anno*, *mes*, *codigo_provincia* y *codigo_municipio"* dado que se han creado nuevas variables con estos datos pero se mantienen las columnas *codigo_ccaa* y *codigo_provincia*.

```{r}
datos_elecciones <- datos_elecciones |>
  mutate(fecha = glue("{anno}-{mes}"),
         cod_mun = glue("{codigo_ccaa}-{codigo_provincia}-{codigo_municipio}"),
         .before = "codigo_ccaa") |> 
  select(-c(anno, mes, codigo_municipio))
```

## CÓDIGOS MUNICIPIOS

Unimos las tablas datos_elecciones y cod_mun a fin de que en la base final aparezca el nombre de los municipios.

```{r}
datos_elecciones <- datos_elecciones |> 
  inner_join(cod_mun, by = "cod_mun") |> 
  relocate(municipio, .after = cod_mun)
```

## SIGLAS

En la base de datos "siglas" se normalizan las siglas de los partidos políticos. Por ejemplo, se asignaron a tres denominaciones de Convergència i Unió unas únicas siglas para unificar la información de este partido.

```{r}
siglas |>
  filter(str_detect(str_to_lower(denominacion), "^conver.*uni|^conver.*cata")) |> 
  distinct() |> 
  mutate(siglas_new = "CiU")
```

\newpage

Así, se realiza la siguiente recodificación para unificar las denominaciones de los partidos:

```{r}
siglas <- siglas |> 
  mutate(siglas=case_when(str_detect(str_to_lower(denominacion), ".*part.*popul|pp") ~ "PP",
                          # P.P-E.U. nos interesa como PP
                          # listas conjuntas con el Partido Popular en las elecciones municipales y autonómicas de 2007
                          # en las elecciones generales de 2011 se presentó en coalición con el Partido Popular
                          str_detect(str_to_lower(denominacion), "^part.*socialist|^socialist.*teruel") ~ "PSOE",
                          str_detect(str_to_lower(denominacion), "^ciudadanos.*partido|^ciutadans") ~ "C's",
                          str_detect(str_to_lower(denominacion), "vasco") ~ "PNV",
                          str_detect(str_to_lower(siglas), "bng") ~ "BNG",
                          str_detect(str_to_lower(siglas), "comprom") &
                            !str_detect(siglas,"^0-9")~ "COMPROMÍS", # para evitar COMPROMÍS 2
                          str_detect(str_to_lower(denominacion), "^conver.*uni|^conver.*cata") ~ "CiU",
                          # El 19 de septiembre de 1978 [Convergencia Democrática de Cataluña] se coalizó con Unió Democràtica de Catalunya
                          # El 18 de junio de 2015 Convergència Democràtica de Catalunya anunció el fin de Convergència i Unió 
                          str_detect(str_to_upper(denominacion), "VERDES|PODEM|EZKER|COMUNISTA|ZQUIERDA REPUBLICANA
                                     |VERDS|IZQUIERDA UNIDA|EN MAREA|UNIDAD POPULAR|EQUO") & # importante que el | esté en esta línea y no al final de la anterior
                            !str_detect(str_to_upper(stringi::stri_trans_general(denominacion, id = "Latin-ASCII")), "MAS PAIS") ~ "UP",
                          str_detect(str_to_lower(siglas), "erc") |
                            str_detect(tolower(denominacion), "esquerra republicana") ~ "ERC",
                          # FRONT PEL PAIS VALENCIA-ERC --> ERC
                          # https://www.vilaweb.cat/noticia/1142933/20000710/front-pais-valencia-fusionara-erc.pdf
                          str_detect(str_to_upper(denominacion), "EH|EUSKO|ARALAR") | 
                            str_detect(str_to_upper(siglas), "EH|EUSKO|ARALAR")~ "EH - BILDU",
                          str_detect(str_to_upper(stringi::stri_trans_general(denominacion, id = "Latin-ASCII")), "MAS PAIS") ~ "MÁS PAÍS",
                          str_detect(str_to_upper(denominacion), "VOX") ~ "VOX",
                          TRUE ~ "Otros"),
         .after = denominacion)

siglas <- siglas |>  
  select(denominacion, siglas) |>  
  distinct()
```

Se procede a añadir las siglas de los partidos a la tabla de datos_encuestas.

```{r}
datos_elecciones_siglas <- datos_elecciones |>
  left_join(siglas, by = c("partido_politico" = "denominacion")) |> 
  relocate(siglas, .before = partido_politico)
```

\newpage

Sin embargo, no todos los partidos políticos de la base de datos de elecciones se encuentran en la base de datos de siglas, por lo tanto debemos recurrir a un código que pueda reducir a siglas todos los partidos políticos de la base de datos de elecciones.

Dónde se considera:

-   PARTIDO SOCIALISTA OBRERO ESPAÑOL (cuidado: tiene/tuvo federaciones - sucursales - con algún otro nombre)
-   PARTIDO POPULAR
-   CIUDADANOS (cuidado: tiene/tuvo federaciones - sucursales - con algún otro nombre)
-   PARTIDO NACIONALISTA VASCO
-   BLOQUE NACIONALISTA GALEGO
-   COMPROMÍS
-   CONVERGÈNCIA I UNIÓ
-   UNIDAS PODEMOS - IU (cuidado que aquí han tenido nombres variados - IU, los verdes, podem, ezker batua, ...- y no siempre han ido juntos, pero aquí los analizaremos juntos
-   ESQUERRA REPUBLICANA DE CATALUNYA
-   EH - BILDU (son ahora una coalición de partidos formados por Sortu, Eusko Alkartasuna, Aralar, Alternatiba)
-   MÁS PAÍS
-   VOX7\*
-   "OTROS"

```{r}
datos_elecciones <- datos_elecciones |> 
  mutate(siglas = case_when(str_detect(str_to_lower(partido_politico), ".*part.*popul|pp") ~ "PP",
                          # P.P-E.U. nos interesa como PP
                          # listas conjuntas con el Partido Popular en las elecciones municipales y autonómicas de 2007
                          # en las elecciones generales de 2011 se presentó en coalición con el Partido Popular
                          str_detect(str_to_lower(partido_politico), "^part.*socialist|^socialist.*teruel") ~ "PSOE",
                          str_detect(str_to_lower(partido_politico), "^ciudadanos.*partido|^ciutadans") ~ "C's",
                          str_detect(str_to_lower(partido_politico), "vasco") ~ "PNV",
                          str_detect(str_to_lower(partido_politico), "galego") ~ "BNG",
                          str_detect(str_to_lower(partido_politico), "comprom") &
                            !str_detect(partido_politico,"^0-9")~ "COMPROMÍS", # para evitar COMPROMÍS 2
                          str_detect(str_to_lower(partido_politico), "^conver.*uni|^conver.*cata") ~ "CiU",
                          # El 19 de septiembre de 1978 [Convergencia Democrática de Cataluña] se coalizó con Unió Democràtica de Catalunya
                          # El 18 de junio de 2015 Convergència Democràtica de Catalunya anunció el fin de Convergència i Unió 
                          str_detect(str_to_upper(partido_politico), "VERDES|PODEM|EZKER|COMUNISTA|ZQUIERDA REPUBLICANA
                                     |VERDS|IZQUIERDA UNIDA|EN MAREA|UNIDAD POPULAR|EQUO") & # importante que el | esté en esta línea y no al final de la anterior
                            !str_detect(str_to_upper(stringi::stri_trans_general(partido_politico, id = "Latin-ASCII")), "MAS PAIS") ~ "UP",
                          str_detect(str_to_lower(partido_politico), "erc") |
                            str_detect(tolower(partido_politico), "esquerra republicana") ~ "ERC",
                          # FRONT PEL PAIS VALENCIA-ERC --> ERC
                          # https://www.vilaweb.cat/noticia/1142933/20000710/front-pais-valencia-fusionara-erc.pdf
                          str_detect(str_to_upper(partido_politico), "EH|EUSKO|ARALAR") | 
                            str_detect(str_to_upper(partido_politico), "EH|EUSKO|ARALAR")~ "EH - BILDU",
                          str_detect(str_to_upper(stringi::stri_trans_general(partido_politico, id = "Latin-ASCII")), "MAS PAIS") ~ "MÁS PAÍS",
                          str_detect(str_to_upper(partido_politico), "VOX") ~ "VOX",
                          TRUE ~ "Otros")) #
#|>   select(partido_politico)
```

\newpage

Una vez que hemos normalizado los nombres de los partidos políticos a una lista de trece siglas, agrupamos la información que antes estaba a nivel de partido político a nivel de siglas.

El dataset datos_elecciones no es excesivamente grande, pero intentamos hacer la agrupación de la información lo más eficiente posible.

Para ello, cogemos una muestra aleatoria del dataset y vemos de qué forma es más rápido:

-   summarise con todas las columnas en el by (se agrega directamente la información).
-   mutate con las columnas que sirven de identificador del dato y posterior distinct (se calcula la información agrupada y luego se quitan datos duplicados).

```{r}
sample_1 <- datos_elecciones |>
  slice_sample(prop = 0.05, by = c(fecha, codigo_ccaa))
```

```{r}
#| echo: false
# validacion:
datos_elecciones |> count(fecha, codigo_ccaa) |>
  mutate(p = round(100*n/sum(n),1), .by = fecha) |>
  slice_max(fecha) |> head(5) |> rename(`Freq muestra(n)`=n,"Freq muestra(%)"=p)
```

\newpage

```{r}
#| echo: false
# validacion:
sample_1 |> count(fecha, codigo_ccaa) |>
  mutate(p = round(100*n/sum(n),1), .by = fecha) |>
  slice_max(fecha) |> head(5) |> rename(`Freq muestra(n)`=n,"Freq muestra(%)"=p)
```

```{r}
# microbenchmark(sample_1 |> summarise(votos = sum(votos), .by=everything()[! everything() %in% c('votos')]) |> ungroup(),
#                sample_1 |> mutate(votos = sum(votos), .by=c(fecha, cod_mun, siglas)) |> distinct() |>ungroup(),
#                times=100)
rm(sample_1)
```

```{r}
datos_elecciones <- datos_elecciones |>
  summarise(votos = sum(votos), .by=everything()[! everything() %in% c('votos')])
```

Con la estructura final de la tabla datos_elecciones cambiamos el formato de algunas columnas.

```{r}

datos_elecciones <- datos_elecciones |> 
  mutate(siglas = factor(siglas, levels = c("BNG","C's","CiU","COMPROMÍS","EH - BILDU","ERC","MÁS PAÍS","PNV","PP", "PSOE","UP","VOX", "Otros")))


str(datos_elecciones, give.attr=0, max.level=3, vec.len=3)
```

\newpage

## LIMPIEZA DE DATOS

Para evitar trabajar con datos erróneos se realizan algunas revisiones lógicas de los datos, en busca de detectar errores de ingreso.

Se crea un dataset con información a nivel municipio con el identificador de este y datos de censo electoral, mesas y participación para cada fecha.

```{r}
datos_elecciones_maestra <- datos_elecciones |> distinct(fecha, cod_mun, numero_mesas, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |> 
  mutate(votos = votos_blancos + votos_nulos + votos_candidaturas,
         p_votos = votos / censo,
         p_votos_blancos = votos_blancos / censo,
         p_votos_nulos = votos_nulos / censo,
         p_votos_candidaturas = votos_candidaturas / censo,
         p_participacion_1 = participacion_1 / censo,
         p_participacion_2 = participacion_2 / censo)
```

\newpage

La distribución de las variables numéricas puede ser interesante observarlas con su trasformación logarítma debido a su gran dispersión y otras (los cálculos de porcentajes) parecen tener valores incoherentes (mayor número de votos que censados).

```{r}
#| warning: false
datos_elecciones_maestra |> select(where(is.numeric)) |> 
  mutate(log_censo = log(censo),
         log_numero_mesas = log(numero_mesas),
         log_participacion_1 = log(participacion_1),
         log_participacion_2 = log(participacion_2),
         log_votos = log(votos),
         log_votos_nulos = log(votos_nulos),
         log_votos_blancos = log(votos_blancos),
         log_votos_candidaturas = log(votos_candidaturas)) |> 
  select(matches("p_|log_")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(x=value))+
  tema_7 +
  geom_density()+facet_wrap(.~name, scales = "free")
```

También se encuentran datos de participación erróneos como:

-   Datos de participación mayores a 1.\
-   Datos del primer avance superiores al segundo avances / datos del primer avance superior a 1.\
-   Datos del segundo avance a cero.

En la primera casuística, eliminamos los registros donde el número de votos es superior al número de censados. (solo dos registros)

```{r}
datos_elecciones_maestra <- datos_elecciones_maestra |> anti_join(datos_elecciones_maestra |> filter(p_votos>1), by=c("fecha","cod_mun") )
dim(datos_elecciones_maestra)
```

\newpage

Para la tercera casuística, los registros donde el dato del segundo avance es cero pero el dato del primer avance ha sido mayor a cero vamos a imputarlos. Los casos donde tanto el primer como el segundo avance es cero, se dan por válidos ya que el censo electoral de esos municipios es muy pequeño (vamos a suponer que todos los censados del pueblo fueron a votar a última hora).

```{r}
datos_elecciones_maestra |> filter( p_participacion_1==0 & p_participacion_2==0 ) |> select(fecha,cod_mun,censo,p_participacion_1,p_participacion_2, p_votos)
```

En los casos donde el dato del primer avance es superior al segundo se buscan municipios similares a él (aquellos que para esa fecha tuvieron un censo electoral de más/menos diez por ciento y que el dato del segundo avance no es superior al suyo) y se sustituye su dato de participación por la media de estos municipios similares. Hacemos el mismo trabajo para casos donde el dato del primer avance es superior a uno. En caso de no poder ser posible (pocos municipios similares, el dato imputado sigue siendo superior, etc.) imputamos el valor de la participaación en el segundo avance.

```{r}
datos_elecciones_maestra |> filter( p_participacion_1>1 | p_participacion_1>p_participacion_2 ) |> select(fecha,cod_mun,censo,p_participacion_1,p_participacion_2)
```

\newpage

```{r}
correcion_df <- function(data, cond_errata){
  a <- data |> filter( eval(parse(text=cond_errata)) )
  
  return(as_tibble(a))
  
}

correcion_dato_censal <- function(data, var_errata, fecha_errata, mun_errata){
  
  censo_errata <- data |> filter(fecha==fecha_errata & cod_mun==mun_errata) |> select(censo) |> pull()
  part_2_tope <- data |> filter(fecha==fecha_errata & cod_mun==mun_errata) |> select(p_participacion_2) |> pull()
  
  varlor_new <- data |> filter(fecha==fecha_errata & cod_mun!=mun_errata & eval(parse(text=var_errata))<=1 & p_participacion_2<=part_2_tope) |>
    filter(between(censo,
                   censo_errata-censo_errata*0.10,
                   censo_errata+censo_errata*0.10)) |> select(all_of(var_errata)) |> 
    sapply(, FUN="mean", na.rm = TRUE)
  
  if (is.na(varlor_new)) { varlor_new = part_2_tope}
  if (varlor_new > part_2_tope) { varlor_new = part_2_tope}
  # print de validación
  # print(data |> filter(fecha==fecha_errata & cod_mun!=mun_errata & eval(parse(text=var_errata))<=1) |>
  #         filter(between(censo,
  #                        censo_errata-censo_errata*0.10,
  #                        censo_errata+censo_errata*0.10)) |> select(fecha,cod_mun,censo,var_errata) |> 
  #         mutate(val1=censo_errata-censo_errata*0.10,val2=censo_errata+censo_errata*0.10))
  
  return(varlor_new)
  
}
```

```{r}
cond_errata_1 = "(p_participacion_1>1 | p_participacion_1>p_participacion_2)"

new_data <- 
correcion_df(datos_elecciones_maestra,cond_errata_1) |>
  mutate(p_participacion_1 = correcion_dato_censal(data = datos_elecciones_maestra, # corrijo con la base de datos original
                                                   var_errata="p_participacion_1",
                                                   fecha_errata=fecha,
                                                   mun_errata=cod_mun),
         .by = c(fecha,cod_mun))
```

```{r}
new_data

datos_elecciones_maestra <- datos_elecciones_maestra |> anti_join(new_data, by=c("fecha","cod_mun"))
datos_elecciones_maestra <- rbind(datos_elecciones_maestra,new_data)
```

Comprobamos que ya no quedan registros con ese tipo de error.

```{r}
datos_elecciones_maestra <- datos_elecciones_maestra |> anti_join(new_data, by=c("fecha","cod_mun"))
datos_elecciones_maestra <- rbind(datos_elecciones_maestra,new_data)
datos_elecciones_maestra |> filter( p_participacion_1>1 | p_participacion_1>p_participacion_2 ) |> select(fecha,cod_mun,censo,p_participacion_1,p_participacion_2)
```

\newpage

## Mario:::: corregir esto con el warning, comprobar y borrar.

```{r}
datos_elecciones_maestra |> 
  filter( p_participacion_1==0 & p_participacion_2==0 ) |> 
  select(fecha,cod_mun,censo,p_participacion_1,p_participacion_2, p_votos)
```

```{r}
datos_elecciones_maestra |> select(where(is.numeric)) |> 
  mutate(log_censo = log(censo),
         log_numero_mesas = log(numero_mesas),
         log_participacion_1 = log(participacion_1),
         log_participacion_2 = log(participacion_2),
         log_votos = log(votos),
         log_votos_nulos = log(votos_nulos),
         log_votos_blancos = log(votos_blancos),
         log_votos_candidaturas = log(votos_candidaturas)) |> 
  select(matches("p_|log_")) |> 
  pivot_longer(cols = everything()) |> 
  ggplot(aes(x=value))+
  tema_7 +
  geom_density() +
  facet_wrap(.~name, scales = "free")
```

\newpage

## ENCUESTAS

Por otro lado, de la base de encuestas, descartamos aquellas encuestas en las que:

-   hagan referencia a elecciones anteriores a 2008.

-   Sean a pie de urna.

-   Tengan un tamaño muestral inferior a 750 o que sea desconocido.

-   Tengan menos de 1 o menos días de trabajo de campo.

```{r}
encuestas <- encuestas |>  filter(!date_elec<"2008-01-01" & # descarto que hagan referencia a elecciones anteriores a 2008
                                    !exit_poll & # descarto que sean a pie de urna
                                    (size >= 750 & !is.na(size)) & # descarto que tenga un tamaño muestral inferior a 750 o que sea desconocido
                                    (field_date_to-field_date_from) > 1# descarto que tengan menos de 1 o menos días de trabajo de campo
                                    )

```

De nuevo, se eliminan aquellas columnas que no aporten información (aquellas que tengan un único valor), como también aquellas sin valores informados.

```{r}
#| results: hold
cols_sin_informacion <- encuestas |> 
  summarise(across(everything(), n_distinct)) |>  
  pivot_longer(cols = everything()) |>  
  filter(value==1) |>  select(name) |>  
  pull()

encuestas |>  
  select(all_of(cols_sin_informacion)[1:5]) |>  
  summary() # todo NA excepto exit_poll que es todo a no pie de urna
# decidir si ponerlo pq es muy grande el output

encuestas <- encuestas |>  
  select(-all_of(cols_sin_informacion))
```

\newpage

Se eliminan las columnas: `r cols_sin_informacion`.

-   *type_survey*: valor constante national.

-   *exit_poll*: valor constante TRUE.

-   *UCD, PCE...*: partidos políticos con toda la información a NA.

Se transforma la base de datos encuestas a formato tidy.

```{r}
encuestas <- encuestas |>
  pivot_longer(cols = -("date_elec":"turnout"),
               names_to = "siglas",
               values_to = "estimacion_votos") |> 
  drop_na(estimacion_votos) 
```

Los datasets finales con los que trabajaremos en el análisis son encuestas y datos_elecciones, que son dos tibbles y están en formato tidy, lo que nos ayudará a realizar los análisis correspondientes.

Se utilizaron tibbles para almacenar los datos de las encuestas y los datos de las elecciones, se eligió este formato por las siguientes razones:

-   Los nombres de las columnas de un tibble hacen que los datos sean más fáciles de entender.

-   Los tipos de datos específicos de los valores de un tibble ayudan a prevenir errores, con los que se trabaja en el análisis son adecuados para el estudio propuesto.

-   Permiten el uso de pipes y tidyverse.

\newpage

Los datasets contienen los datos necesarios para analizar la evolución de la opinión pública en España desde 2008 y son: **encuestas,** tibble de dimensión [13379\*10]{.underline} y **datos_elecciones**, tibble de dimensión [367241\*13]{.underline}. La unificación de los datos de la base cod_mun con los datos de la base datos_elecciones es necesaria para poder realizar análisis geográficos.

Además las siglas las hemos definido de acuerdo a las indicaciones señaladas, excluyendo los datos de la base "siglas" debido a la irregularidad de los datos para el presente estudio, considerando que no abarca todos los partidos politicos que sugiere el proyecto.

```{r}
#| collapse: true
head(encuestas)
```

```{r}
#| collapse: true
head(datos_elecciones)
```

Cabe destacar que no vamos a necesitar el dataset de cod_mun ya que hemos añadido su información a datos_elecciones y siglas debido a que hemos descartado su utilidad.

```{r}
#Colocación de colores para cada sigla según su color oficial
datos_elecciones <- datos_elecciones |>
  mutate(color_politico = case_when(siglas == "PP" ~ "#3399FF",
                         siglas == "PSOE" ~ "#F6350B",
                         siglas == "C's" ~ "#FF5824",
                         siglas == "PNV" ~ "#008135",
                         siglas == "BNG" ~ "#76b3dd",
                         siglas == "COMPROMÍS" ~ "#de6c25",
                         siglas == "CiU" ~ "#FF0000",
                         siglas == "UP" ~ "#6D50B3",
                         siglas == "ERC" ~ "#ffbf41",
                         siglas == "EH - BILDU" ~ "#00bda1",
                         siglas == "MÁS PAÍS" ~ "#E61455",
                         siglas == "VOX" ~ "#73B446",
                         TRUE ~ "#462B25"))

#Generación de tibble con colores para cada sigla según su color oficial
colores_politicos <- datos_elecciones |> 
  distinct(siglas) |> 
  mutate(color_politico=case_when(siglas == "BNG" ~ "#76b3dd",
                                  siglas == "C's" ~ "#FF5824",
                                  siglas == "CiU" ~ "#FF0000",
                                  siglas == "COMPROMÍS" ~ "#de6c25",
                                  siglas == "EH - BILDU" ~ "#00bda1",
                                  siglas == "ERC" ~ "#ffbf41",
                                  siglas == "MÁS PAÍS" ~ "#E61455",
                                  siglas == "PNV" ~ "#008135",
                                  siglas == "PP" ~ "#3399FF",
                                  siglas == "PSOE" ~ "#F6350B",
                                  siglas == "UP" ~ "#6D50B3",
                                  siglas == "VOX" ~ "#73B446",
                                  TRUE ~ "#462B25"))

#Cálculo de número de elecciones
n_elecc <- datos_elecciones |> 
  distinct(fecha) |> 
  pull() |> 
  length()
```

\newpage

```{r}
# Censo total en cada elección
maestra_censo <- datos_elecciones |> distinct(fecha, cod_mun, censo) |> summarise(censo=sum(censo), .by = fecha)

# Total de votos por sigla en cada uno de las fechas (agupamos todos los votos de todos los municipios)
data_1 <- datos_elecciones |>
  summarise(votos=sum(votos), .by = c(fecha, siglas,color_politico)) |> 
  left_join(maestra_censo, by = "fecha")
  # left_join(datos_elecciones |> distinct(fecha, cod_mun, censo) |> summarise(censo=sum(censo), .by = fecha), by = "fecha")

min_votos <- data_1 |> summarise(votos=sum(votos), .by=fecha) |> 
  summarise(min_v=min(votos)) |> pull()

participacion <- data_1 |> summarise(participacion=sum(votos)/max(censo), .by=fecha)

p_votos <- data_1 |> summarise(votos = sum(votos), .by=fecha) |> left_join(maestra_censo, by = "fecha") |> 
  mutate(p_votos = votos/censo) |> select(p_votos) |> pull()
```

# Análisis de votaciones en España en el rango 2008 - 2019

En España se han realizado 6 votaciones en el rango de años 2008 a 2019, para analizar estas votaciones, se utilizaron los **datos electorales** con información del tipo de elección, mes y año, vuelta electoral, códigos geopolíticos, número de mesas, censo electoral, participación en cada avance y número de votos y su proporción, por otro lado, se utilizaron las **encuestas electorales** desde 2008 incluyendo sus casas encuestadoras, la fecha de las futuras elecciones y el tipo de encuesta. De manera anexa se utilizaron las siglas de los partidos políticos y los códigos de los municipios.

\newpage

## Distribución de votos

España cuenta en la actualidad con 6 partidos políticos de corte nacional, y 6 partidos políticos de estatus autonómico o nacionalista. Sus resultados electorales en las `r n_elecc` elecciones se pueden apreciar en el siguiente gráfico:

```{r}
datos_elecciones <- datos_elecciones |> 
  mutate(corte_partido = if_else(siglas %in% c("PSOE","PP","VOX","CS","MP","UP"),
                                                                 "Nacional", "Autonómico/Nacionalista"))

pr1 <- datos_elecciones |> 
  group_by(corte_partido, fecha) |> 
  summarise(suma = sum(votos)) |> 
  group_by(fecha) |> 
  mutate(prop = round(suma/(sum(suma)),2))

pr1 |> 
  group_by(corte_partido) |> 
  ggplot(aes(x = fecha, y = prop, fill = corte_partido)) +
  geom_col(position = "fill") + 
  geom_text(aes(label = percent(prop)), 
            format = "%.0f%%", position = position_fill(0.5)) +
  scale_fill_manual(values = colores) +
  tema_7 + 
  theme(legend.position = "bottom") +
  labs(
    title = "Porcentaje de votos nacionales y autonómicos por elección ",
    x = "Fecha elección",
    y = "Proporción de votos",
    fill = "Partidos")
  
```

Se puede apreciar que hasta el 2011 la dominancia de los partidos de corte nacional fue sobre el 80%, la que disminuyó entre las votaciones del 2015 a abril del 2019 a valores de entre 71% y 75%, y en la votación más reciente, volvió a aumentar al 78%.

\newpage

## Votaciones en municipios grandes

Al momento de evaluar solo aquellos municipios con más de 100.000 habitantes, los resultados cambian drásticamente.

```{r}
pr2 <- datos_elecciones |> 
  filter(censo > 100000) |> 
  group_by(fecha, siglas) |> 
  summarise(suma = sum(votos)) |> 
  group_by(fecha) |> 
  mutate(prop = round(suma/(sum(suma)),2)) |> 
  mutate(color_politico = case_when(siglas == "BNG" ~ "#76b3dd",
                                  siglas == "C's" ~ "#FF5824",
                                  siglas == "CiU" ~ "#FF0000",
                                  siglas == "COMPROMÍS" ~ "#de6c25",
                                  siglas == "EH - BILDU" ~ "#00bda1",
                                  siglas == "ERC" ~ "#ffbf41",
                                  siglas == "MÁS PAÍS" ~ "#E61455",
                                  siglas == "PNV" ~ "#008135",
                                  siglas == "PP" ~ "#3399FF",
                                  siglas == "PSOE" ~ "#F6350B",
                                  siglas == "UP" ~ "#6D50B3",
                                  siglas == "VOX" ~ "#73B446",
                                  TRUE ~ "#462B25")) |> 
  ungroup()

cols <- rlang::set_names(colores_politicos$color_politico, 
                         colores_politicos$siglas)

pr2 |> 
  ggplot() +
  geom_col(aes(x = fecha, y = prop, fill = siglas), 
           position = "fill", alpha = 0.9) + 
  #geom_text(aes(label = (prop*100)), position = position_fill(0.5)) +
  tema_7 + 
  scale_fill_manual(values = cols) +
  theme(legend.position = "right") +
  labs(
    title = "Proporción de votos en cada elección por partido",
    caption = "Solo considerando municipios con más de 100.000 habitantes.",
    x = "Fecha de elección",
    y = "Proporción de votos",
    fill = "Partido político"
  )

```

\newpage

## Partido ganador por elección

```{r}
#| eval: false
pr2 |>
  filter(siglas == "PSOE" | siglas == "PP") |> 
  group_by(fecha) |>
  ggplot(aes(x = fecha, y = prop, fill = color_politico)) +
  scale_fill_manual(values = pr2$color_politico) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = siglas), position = position_stack(vjust = 0.5), size = 3) +
  #geom_hline(yintercept = 0.5, linetype = "dashed") +
  tema_7 +
    labs(
    title = "Partido ganador por elección",
    caption = "Solo considerando municipios con más de 100.000 habitantes.",
    x = "Fecha de elección",
    y = "Proporción de votos"
  )
```

El partido ganador en las elecciones del 2008 es el PSOE, luego el PP es el ganador entre los años 2011 y 2016, y finalmente, el PSOE vuelve a ser el partido ganador en las dos elecciones del 2019. Esto muestra indicios de una marcada tendencia bipartidista, en el período estudiado en España.

\newpage

## Tendencias bipartidistas

Para revisar esta tendencia bipartidista, se incluyeron los datos de todos los municipios, y la tendencia vuelve a repetirse, cuando el PSOE es el partido ganador, el segundo es el PP, y viceversa.

```{r}
datos_elecciones|> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=2, by=c(fecha, cod_mun)) |> select(fecha, cod_mun, siglas, votos)
 #   fecha   cod_mun   siglas votos
 #   <fct>   <chr>     <fct>  <dbl>
 # 1 2008-03 01-04-001 PSOE     512
 # 2 2008-03 01-04-001 PP       382
 # 3 2008-03 01-04-002 PSOE     532
 # 4 2008-03 01-04-002 PP       340

# Partido más votado
mas_votado1 <- 
datos_elecciones |> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=2, by=c(fecha, cod_mun), with_ties = TRUE) |> select(fecha, cod_mun, codigo_ccaa, siglas, votos) |> 
  slice_max(votos, n=1, by=c(fecha, cod_mun), with_ties = TRUE) |> mutate(posicion = "Más votado")
 #   fecha   cod_mun   siglas votos
 #   <fct>   <chr>     <fct>  <dbl>
 # 1 2008-03 01-04-001 PSOE     512 Más votado
 # 2 2008-03 01-04-002 PSOE     532 Más votado

# Segundo partido más votado
mas_votado2 <- 
datos_elecciones |> arrange(fecha, cod_mun, -votos) |> 
  slice_max(votos, n=2, by=c(fecha, cod_mun), with_ties = TRUE) |> select(fecha, cod_mun, codigo_ccaa, siglas, votos) |> 
  slice_min(votos, n=1, by=c(fecha, cod_mun), with_ties = TRUE) |> mutate(posicion = "Segundo más votado")
 #   fecha   cod_mun   siglas votos
 #   <fct>   <chr>     <fct>  <dbl>
 # 1 2008-03 01-04-001 PP       382 Segundo más votado
 # 2 2008-03 01-04-002 PP       340 Segundo más votado

mas_votado <- rbind(mas_votado1,mas_votado2) |> arrange(fecha, cod_mun, -votos) 

mas_votado |> select(siglas, posicion) |> table()
```

## Parte de Mario

Como no tenemos manera de deshacer un empate de votos, permitimos tener más de un partido en primera posición. En estos casos, todos los partidos que estén en primera posición ocuparán tanto el primer como el segundo puesto.

Así:

```{r}
#| results: hold
mas_votado1 |> filter(fecha=="2019-11" & cod_mun=="01-04-021")
mas_votado2 |> filter(fecha=="2019-11" & cod_mun=="01-04-021")
```

O así:

```{r}
#| results: hold
mas_votado1 |> filter(fecha=="2015-12" & cod_mun=="07-19-010")
mas_votado2 |> filter(fecha=="2015-12" & cod_mun=="07-19-010")
```

Vemos la relación entre el partido más votado y el segundo, teniendo en cuenta todos los municipios para todas las elecciones. Visualmente se aprecia que cuando el PP queda en primer lugar el partido que más veces está en segundo puesto es el PSOE. Y viceversa. Cuando el PSOE ocupa la primera posición en votos el partido que más veces está tras él es el PP.

```{r}
mas_votado1 |> select(fecha, cod_mun, siglas, posicion) |>
  left_join(mas_votado2 |> select(fecha, cod_mun, siglas, posicion),
            by=c("fecha","cod_mun"), suffix = c("_primero","_segundo")) |> 
  make_long("siglas_primero","siglas_segundo") |> 
  ggplot(aes(x = x, 
             next_x = next_x, 
             node = node, 
             next_node = next_node,
             fill = factor(node),
             label = node)) +
  tema_7 +
  scale_fill_manual(values = cols) +
  geom_sankey(flow.alpha = 0.5, node.color = 1) +
  geom_sankey_text(size = 3.5)+
  geom_sankey_label(size = 3.5, color = 1, fill = "white") +
  theme(legend.position = "none") +
  labs(
    title = "Relación entre el primer y segundo partido más votado",
    x = "",
    y = "Número de municipios y elecciones",
    caption = "Considerando todas las elecciones y todos los municipios"
  )
```

Vemos un pequeño flujo residual que va de PSOE en primera posición a PSOE en segunda posición. Esto se debe a los casos de empate en el partido más votado donde decidíamos poner a ambos partidos como primer y segundo partido más votado.

```{r}
mas_votado1 |> select(fecha, cod_mun, siglas, posicion) |> 
  filter(siglas=="PSOE") |> 
  left_join(mas_votado2 |> 
            select(fecha, cod_mun, siglas, posicion),
            by = c("fecha","cod_mun"), 
            suffix = c("_primero","_segundo")) |> 
  # make_long("siglas_primero","siglas_segundo") |> 
  make_long("siglas_segundo","siglas_primero") |> 
  ggplot(aes(x = x, 
             next_x = next_x, 
             node = node, 
             next_node = next_node,
             fill = factor(node),
             label = node))+
  geom_sankey(flow.alpha = 0.5, node.color = 1) +
  geom_sankey_text(size = 3.5)+
  geom_sankey_label(size = 3.5, color = 1, fill = "white") +
  scale_fill_manual(values = cols) +
  theme_sankey() +
  tema_7 +
  theme(legend.position = "none") +
  coord_flip(expand = FALSE) +
  labs(title = "Partidos en segunda posición cuando el PSOE ganó",
       x = "",
       y = "Número de municipios y votaciones",
       caption = "Considerando todas las elecciones y todos los municipios")
```

```{r}
mas_votado1 |> filter(fecha=="2008-03" & cod_mun=="01-18-094")
```

Igual que hemos visto casos donde primer y segundo puesto estaban empatados, merece la pena mirar dónde esa diferencia es máxima. Solo nos enfocaremos en los municipios donde el censo sea alto, pongamos un marco de 2.000 censados en adelante, ya que en municipios con pocos censados electorales la diferencia entre primer y segundo partido serán muy pequeñas y esto nos puede dar una distribución de la variable "diferencia entre primer y segundo partido más votado" con una cola izquierda muy pesada.

Con esta restricción de municipios con mayor censo sabemos que si vemos una diferencia de pocos votos es realmente un resultado ajustado, ya que una diferencia en cinco o diez votos en zonas con pocos censados electorales no tiene tanto impacto.

Para este punto se plantea agrupar los datos de los municipios ya que hasta ahora hemos estado trabajando con medidas repetidas para un mismo municipio (un dato para cada una de las elecciones).

Esto presenta un punto interesante en el nivel de agregación de la información, ya que el hecho de agrupar la información del censo a nivel municipio es para evitar duplicados en un análisis a nivel municipio (en puntos anteriores no era necesaria esta agrupación ya que se estaban analizado resultados electorales independientes). Pero ahora queremos identificar municipios donde la diferencia en votos entre primer y segundo partido fue mayor a lo esperado. Observaciones:

-   Sería de esperar que el censo tuviera poca variabilidad y el hecho de agrupar el número de censados por municipio en cada una de las elecciones no afectase mucho al filtro de municipios con más de 2.000 censados. Pero en los últimos años el tráfico de población de zonas rurales a grandes ciudades junto con el fallecimiento de personas de mayor edad y poca natalidad en estos municpios (debido al tráfico de la población) ha hecho que los municipios más pequeños tengan cada año menos censados electorales (poca "renovación" en el censo electoral al no tener jóvenes que sustituyan a los censados electorales más seniors que van saliendo del censo electoral).\
-   Como queremos ver qué municipios han tenido mayor diferencia de votos, no podemos agrupar en bruto los votos de cada partido en cada una de las elecciones a un único registro, aunque podemos usar alternativas como "diferencia media entre primer y segundo partido en la elección *x*".

Para cada fecha se marca si el municipio tenía menos de 2.000 censados electorales o no. La evolución de esta variable en el tiempo es la siguiente:

```{r}
#| warning: false
#| results: hold
datos_elecciones |> 
  mutate(censo_menor2000 = if_else(censo<2000,1,0)) |> 
  distinct(fecha, cod_mun, censo_menor2000)|> 
  summarise(media=mean(censo_menor2000), .by=(fecha))

datos_elecciones |> 
  mutate(censo_menor2000 = if_else(censo<2000,1,0)) |> 
  distinct(fecha, cod_mun, censo_menor2000) |> 
  pivot_wider(names_from = fecha, values_from = censo_menor2000) |> 
  select(-cod_mun) |> 
  group_by_all() |> 
  summarise(n=n()) |>  
  print(n = 1e3)
```

**HIGHLIGHT**

El municipio de Cesuras (La Coruña) tiene datos solo para 2008-03 y 2011-11 a pesar de tener un censo y censo electoral superior a 2.000.

```{r}
datos_elecciones |> 
  filter(cod_mun=="11-15-026") |> 
  distinct(fecha,cod_mun,municipio,censo,votos_candidaturas)
```

Esto es debido a que en 2013 se crea el municipio Oza-Cesuras como fusión de los municipios de Oza de los Ríos y Cesuras.

```{r}
mas_votado |> 
  anti_join(datos_elecciones |> 
              select(fecha, cod_mun, censo) |> 
              filter(censo<2000),
            by = c("fecha", "cod_mun")) |> 
  group_by(fecha,cod_mun) |>  
  mutate(lag_votos = votos - lag(votos)) |> 
  mutate(lag_votos=-lag_votos) |> 
  head()

```

La distribución de la diferencia de votos para estos mismos municipios.

```{r}
#| results: hold
data_2 <- mas_votado |>  
  mutate(lag_votos = votos - lag(votos), .by = c(fecha,cod_mun)) |> 
  mutate(lag_votos = -lag_votos) |>
  select(c(fecha, cod_mun, codigo_ccaa, lag_votos)) |> 
  drop_na() |> 
  ungroup() |> 
  anti_join(datos_elecciones |> 
              select(fecha, cod_mun, codigo_ccaa, censo) |> 
              filter(censo<2000), by = c("fecha", "cod_mun")) |> 
  left_join(datos_elecciones |> 
              distinct(fecha, cod_mun, municipio, censo))

plot1 <- data_2 |> 
  ggplot(aes(x=lag_votos)) +
  tema_7 +
  geom_density() +
  labs(y = "Densidad de votos")

plot2 <- data_2 |> 
  ggplot(aes(x=log(lag_votos)))+
  tema_7 +
  geom_density() +
  labs(y = "Densidad de votos")

grid.arrange(plot1, plot2, ncol = 2)
```

La distribución del logaritmo de la diferencia de votos sigue una distribución normal y mucho más visual que la distribucion original que nos permite la búsqueda de outliers.

```{r}
plot1 <- data_2 |> 
  filter(lag_votos>0) |> 
  ggplot(aes(x=log(lag_votos), y = codigo_ccaa , fill = codigo_ccaa))+
  geom_density_ridges()+
  tema_7 +
  theme(legend.position = "none") +
  labs(
    x = "Logaritmo de votos con lag",
    y = "Codigo Comunidad autónoma"
  )

plot2 <- data_2 |> filter(lag_votos>0) |> 
  ggplot(aes(y = log(lag_votos) , x = codigo_ccaa)) +
  tema_7 +
  geom_boxplot() +
  labs(
    x = "Código Comunidad autónoma",
    y = "Logaritmo de votos con lag"
  )

grid.arrange(plot1, plot2, nrow = 2)
```

Para determinar los municipios-fecha con mayor diferencia de voto podemos medir esta diferencia de forma absoluta o de forma relativa.

-   Absoluta: máximo número en bruto en diferencia de votos.\
-   Relativa: máxima diferencia de votos medida sobre los censados electorales.

Esta segunda forma relativiza la diferencia de votos en función del tamaño de la muestra. Ya que en municipios con mayor censo se espera mayor diferencia en votos.

```{r}
data_2 |> # summarise(censo=mean(censo), lag_votos=mean(lag_votos), .by = cod_mun) |>
  ggplot(aes(x=log(censo), y=log(lag_votos)))+
  geom_point()+
  tema_7 +
  stat_smooth(method = "lm") +
  labs(
    title = "Comparación entre población votante y diferencia absoluta de votos",
       x = "Logaritmo del censo electoral",
       y = "Logaritmo de votos con lag")
```

```{r}
#| collapse: true
data_diff <- data_2 |> select(fecha, cod_mun, municipio, censo, lag_votos) |> mutate(dif_votos_absoluta =  lag_votos,
                                                                                     dif_votos_relativa = round(lag_votos/censo,4))

data_diff |> slice_max(dif_votos_absoluta,n=5)
data_diff |> slice_max(dif_votos_relativa,n=5)
```

El top cuatro de mayor diferencia absoluta en votos pertenencen al municipio 12-28-079 (Madrid). Es decir, Madrid ha tenido la mayor diferencia absoluta de votos entre el primer y el segundo partido más votado en las cuatro elecciones más antiguas.

De los cinco casos con mayor diferencia absoluta de votos cuatro de ellos son del municipio 01-41-901 (Cañada Rosal).

Observando para cada municipio solo su registro con mayor diferencia de votos absoluta/relativa, el ranking queda de la siguiente manera.

```{r}
#| collapse: true
data_diff |> slice_max(dif_votos_absoluta, n=1, by = municipio) |> slice_max(dif_votos_absoluta, n=5)
data_diff |> slice_max(dif_votos_relativa, n=1, by = municipio) |> slice_max(dif_votos_relativa, n=5)
```

Observando en cada elección el municipio con máxima diferencia en votos absoluta/relativa.

```{r}
#| collapse: true
data_diff |> slice_max(dif_votos_absoluta, n=1, by = fecha)
data_diff |> slice_max(dif_votos_relativa, n=1, by = fecha)
```

Como resumen de los rankings anteriores podemoss decir que las máximas diferencias absolutas en votos pertenecen a las grandes ciudades y suele ser Madrid el municpio que presenta la máxima diferencia, sobre todo en elecciones más antiguas (la diferencia relativa en votos ha ido reduciéndose en cada elección). La diferencia relativa en votos es mayor en municipios donde el censo es más bajo.

¿Tendrá algo que ver el porcentaje de voto con los resultados electorales? Miramos primero aquellos municipios y provincias con mayor porcentaje de voto.

```{r}
datos_porcentaje_voto <- datos_elecciones |> distinct(fecha,cod_mun,municipio,codigo_ccaa,censo,votos_blancos,votos_nulos,votos_candidaturas) |>
  mutate(votos_municipio = votos_blancos + votos_nulos + votos_candidaturas,
         p_votos_blancos = round(votos_blancos/censo,2),
         p_votos_nulos = round(votos_nulos/censo,2),
         p_votos_candidaturas = round(votos_candidaturas/censo,2),
         p_voto = round(votos_municipio/censo,2))

# datos_porcentaje_voto <- datos_porcentaje_voto |> left_join(mas_votado, by = c("fecha","cod_mun"))

```

# Mario creo que acá queda mejor un solo gráfico de barras, con 2 colores uno encima del otro (como el chunk 36)

```{r}
plot1 <- datos_porcentaje_voto |>  
  mutate(censo_quantile = ntile(censo , 10)) |> 
  summarise(p_voto=mean(p_voto), .by = censo_quantile) |> 
  ggplot()+
  tema_7 +
  geom_col(aes(x=censo_quantile, y=p_voto, fill = "#e3005a"), show.legend = FALSE) +
  scale_fill_manual(values = "#e3005a") +
  scale_x_continuous(breaks = c(1:10)) +
  labs(x = "Censo electoral en deciles",
       y = "Participación electoral")

plot2 <- datos_porcentaje_voto |>  
  mutate(censo_quantile = ntile(censo , 10)) |> 
  summarise(p_votos_nulos=mean(p_votos_nulos), .by = censo_quantile) |> 
  ggplot() +
  tema_7 +
  geom_col(aes(x = censo_quantile, y = p_votos_nulos, 
               fill = "#00d3da"), show.legend = FALSE) +
  scale_fill_manual(values = "#00d3da") +
  scale_x_continuous(breaks = c(1:10)) +
  labs(x = "Censo electoral en deciles",
       y = "Porcentaje votos nulos")

grid.arrange(plot1, plot2, ncol=2)

datos_porcentaje_voto |>  
  mutate(censo_quantile = ntile(censo , 10)) |> 
  summarise(p_votos_nulos=mean(p_votos_nulos), .by = c(censo_quantile,fecha)) |> 
  ggplot()+
  tema_7 +
  geom_col(aes(x=censo_quantile, y=p_votos_nulos, fill = fecha), alpha = 0.8, show.legend = FALSE)+
  facet_wrap(~fecha)+
  scale_fill_manual(values = colores) +
  scale_x_continuous(breaks = c(1:10)) +
  labs(title = "Porcentaje de votos nulos por elección",
       x = "Censo electoral en deciles",
       y = "Porcentaje votos nulos")
```

Aunque a mayor censo electoral el porcentaje de voto es menor, el porcentaje de votos nulos no parece seguir ninguna tendencia en función del censo. Al igual que con la diferencia de votos, podemos mirar obtener el ranking de votos nulos en frecuencia absoluta o relativa. E igual que antes, la mayor frecuencia absoluta la encontramos en Madrid y Barcelona (con un porcentaje de votos nulos casi inexistente) y la mayor frecuencia relativa la vemos en municipios con muy poco censo electoral.

\newpage

```{r}
#| collapse: true
datos_porcentaje_voto |> select(fecha, cod_mun, municipio, censo, votos_nulos, p_votos_nulos) |> slice_max(votos_nulos, n=5)
datos_porcentaje_voto |> select(fecha, cod_mun, municipio, censo, votos_nulos, p_votos_nulos) |> slice_max(p_votos_nulos, n=5)
```

No podemos comparar el número de votos en dos municipios cuando la diferencia en censados electorales es muy alta. Pero si podemos medir el porcentaje de participación que, por lo dicho en el ejemplo interior, en censos más pequeños hay participación más alta. Si la participación es más alta, ¿el número de votos a las candidaturas es proporcional también? ¿O hay distinto porcentaje de votos nulos votos y votos en blanco en municipios más grandes? Es decir, ¿el porcentaje de votos no destinados a las candidaturas depende del censo?

Vemos es la distribución censal por cuantil y el porcentaje medio de participación, dividido por el porcentaje de votos a las candidaturas, de votos en blanco y de votos nulos (porcentajes medidos como votos -de esas tres categorías- sobre el censo). Vemos cómo la participación baja según aumenta el censo en las poblaciones, pero el porcentaje de votos nulos no sigue esa distribución.

```{r}
# como repaso por si lo queremos ver, en realidad este dato ya le tenemos plasmado en el segundo gráfico
# datos_porcentaje_voto |> mutate(censo_quantile = ntile(censo , 20)) |> 
#   ggplot()+
#   geom_col(aes(x=fecha, y=p_voto))

# Elegir cuál de los tres
# Yo eligiría el tercero pero poniendo dentro de la barra el valor

datos_porcentaje_voto |> mutate(censo_quantile = ntile(censo , 10)) |>
  summarise(p_voto=mean(p_voto), .by = c(fecha, censo_quantile)) |> 
  ggplot()+
  geom_col(aes(x=censo_quantile, y=p_voto))+
  scale_y_break(c(0, 0.65))+
  tema_7 +
  facet_wrap(~fecha) +
  scale_x_continuous(breaks = c(1:10)) +
  labs(x = "Censo electoral en deciles",
       y = "Participación electoral")

datos_porcentaje_voto |> mutate(censo_quantile = factor(ntile(censo , 10))) |> 
  select(fecha, censo_quantile, p_votos_blancos, p_votos_nulos, p_votos_candidaturas, p_voto) |> 
  summarise(p_votos_blancos = mean(p_votos_blancos),
            p_votos_nulos = mean(p_votos_nulos),
            p_votos_candidaturas = mean(p_votos_candidaturas),
            p_voto = mean(p_voto),
            .by = c(fecha, censo_quantile)) |>
  pivot_longer(cols = p_votos_blancos:p_votos_candidaturas,
               values_to = "porcentaje") |> 
  mutate(name=factor(name, levels = c("p_votos_nulos","p_votos_blancos","p_votos_candidaturas"), ordered = TRUE)) |>
  ggplot(aes(x=censo_quantile, y=porcentaje, fill=name), alpha = 0.8)+
  geom_col()+
  tema_7 +
  scale_y_break(c(0, 0.65))+ # opcional?
  facet_wrap(~fecha) +
  scale_fill_manual(values = colores)+
  labs(title = "Distribución de votos por elección", 
       x = "Censo electoral en deciles",
       y = "Porcentaje absoluto",
       fill = "Leyenda")
# title y subtiel: porcentaje total de voto dividido en porcentaje de votos en blanco, nulos y a candidaturas
# leyenda abajo

datos_porcentaje_voto |> mutate(censo_quantile = factor(ntile(censo , 10))) |> 
  select(fecha, censo_quantile, p_votos_blancos, p_votos_nulos, p_votos_candidaturas, p_voto) |> 
  summarise(p_votos_blancos = mean(p_votos_blancos),
            p_votos_nulos = mean(p_votos_nulos),
            p_votos_candidaturas = mean(p_votos_candidaturas),
            p_voto = mean(p_voto),
            .by = c(fecha, censo_quantile)) |>
  pivot_longer(cols = p_votos_blancos:p_votos_candidaturas,
               values_to = "porcentaje") |>
  mutate(name=factor(name, levels = c("p_votos_nulos","p_votos_blancos","p_votos_candidaturas"), ordered = TRUE)) |> 
  ggplot(aes(x=censo_quantile, y=porcentaje, fill=name),  alpha = 0.8)+
  tema_7 +
  geom_col(position = "fill")+
  scale_y_break(c(0, 0.95))+
  facet_wrap(~fecha)+
  scale_fill_manual(values = colores)+
  labs(title = "Distribución de votos por elección", 
       x = "Censo electoral en deciles",
       y = "Porcentaje relativo",
       fill = "Leyenda")
```

```{r}
# Esto es para ver que las tendencias de votos en blanco y votos nulos no son las mismas en cuestión del censo. Aunque me genera la duda si en el gráfico anterior también tengo que hacer el summarise
# Entiendo que no porque al hacer el geom_col él mismo te hace la media, y el geom_point como estás mostrando un punto por cada registro sí que es necesario hacer la media para que no salgan varios puntos uno encima del otro en el mismo cuantil.
datos_porcentaje_voto |> mutate(censo_quantile = factor(ntile(censo , 20))) |> 
  select(fecha, censo_quantile, p_votos_blancos, p_votos_nulos, p_voto) |> 
  summarise(p_votos_blancos = mean(p_votos_blancos),
            p_votos_nulos = mean(p_votos_nulos),
            p_voto = mean(p_voto),
            .by = c(fecha, censo_quantile)) |>
  pivot_longer(cols = p_votos_blancos:p_votos_nulos,
               values_to = "porcentaje") |> 
  ggplot(aes(x=censo_quantile, y=porcentaje, color = name, group = name))+
  tema_7 +
  geom_line()+
  geom_point()+
  facet_wrap(~fecha)+
  scale_color_manual(values = colores)+
  labs(title = "Distribución de votos blancos y nulos", 
       x = "Censo electoral en deciles",
       y = "Porcentaje absoluto",
       fill = "Leyenda")
```

\newpage

En toda elección surgen los rumores sobre si una baja participación favorece a la derecha o a la izquierda, para combatir a esos rumores analizaremos elección a elección los resultados y niveles de participación.

# Mario: acá no sé como crear la leyenda para las lineas

```{r}
datos_elecciones |> summarise(votos=sum(votos), .by=c(fecha, cod_mun, censo, participacion_1, participacion_2)) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(fecha)) |> 
  mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo) |> 
  ggplot(aes(x=fecha))+
  tema_7 +
  geom_col(aes(y=censo))+
  geom_line(aes(y = p_votos*(1/0.00000003)),group=1, color = "red")+
  geom_line(aes(y = p_participacion_1*(1/0.00000003)),group=2, color = "blue")+
  geom_line(aes(y = p_participacion_2*(1/0.00000003)),group=2, color = "green")+
  labs(
    title = "Distribución de participación según bloque horario",
    y = "Censo electoral",
    x = "Fecha elección"
  )
```

Tras interiorizar las tendencias del porcentaje de votos en las distintas fechas, ¿vemos cambios en los resultados electores según el porcentaje de voto?

# Mario: Esto está repetido? no lo entiendo

```{r}
datos_participacion_fecha <- datos_elecciones |> summarise(votos=sum(votos), .by=c(fecha, cod_mun, censo, participacion_1, participacion_2)) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(fecha)) |> 
  mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)

datos_participacion_fecha |> 
  ggplot(aes(x=fecha))+
  geom_col(aes(y=censo))+
  geom_line(aes(y = p_votos*(1/0.00000003)),group=1, color = "red")+
  geom_line(aes(y = p_participacion_1*(1/0.00000003)),group=2, color = "blue")+
  geom_line(aes(y = p_participacion_2*(1/0.00000003)),group=2, color = "green") +
  tema_7
```

```{r}
# lo suyo sería tener un dataset con un distinct de fecha:votos_candidaturas pero no me da tiempo
# como pte
datos_participacion_fecha_municipio <- datos_elecciones |> 
  distinct(fecha, cod_mun, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |> 
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |>
  mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(fecha, siglas_ganador)) |> 
    mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)
# recordemos que tenemos "duplicados" por los empates en el primer puesto

datos_participacion_municipio <- datos_elecciones |> 
  distinct(fecha, cod_mun, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |> 
  mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |>
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(cod_mun, siglas_ganador)) |> # aquí siglas_ganador es necesario porque a veces tenemos dos ganadores en un municipio-fecha, sino sería c(cod_mun, fecha)
  mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)|>
  summarise(censo=mean(censo),
            p_votos=mean(p_votos),
            p_participacion_1=mean(p_participacion_1),
            p_participacion_2=mean(p_participacion_2), .by=c(siglas_ganador))



# ORDENAR FACTOR siglas_ganador POR p_votos PARA QUE EL EJE Y SALGA ORDENADO
# aquí vemos para las elecciones en que gana cada partido político, cuál es la media de participación (votos),
# de participación_1 y participación_2, ponerlo en los títulos
# ¿Se ve claro así?
datos_participacion_municipio |> 
  mutate(siglas_ganador = fct_reorder(siglas_ganador, p_votos)) |> 
  ggplot(aes(y=siglas_ganador))+
  geom_line(aes(x = p_votos*(1/0.00000003)),group=1, color = "red")+
  geom_point(aes(x = p_participacion_1*(1/0.00000003)),group=2, color = "blue")+
  geom_point(aes(x = p_participacion_2*(1/0.00000003)),group=2, color = "green") +
  tema_7 +
  labs(title = "Participación por bloque horario según partido ganador",
       x = "Participación de votantes",
       y = "Partido ganador")
```

```{r}
# datos_participacion_municipio |> mutate(siglas_ganador = fct_reorder(siglas_ganador, p_votos)) %>%
datos_elecciones_maestra |>
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |>
  summarise(censo=sum(censo),
            votos=sum(votos),
            participacion_1=sum(participacion_1),
            participacion_2=sum(participacion_2), .by=c(cod_mun, siglas_ganador)) |> # aquí siglas_ganador es necesario porque a veces tenemos dos ganadores en un municipio-fecha, sino sería c(cod_mun, fecha)
  mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo) |> pivot_longer(cols = c(p_votos, p_participacion_1, p_participacion_2)) |> 
  ggplot( aes(x=name, y=value)) +
  geom_boxplot()+
  facet_wrap(.~siglas_ganador) +
  coord_flip()+
  tema_7
```

```{r}
#| eval: false
# no me sale. y lo más parecido que sale no da los resultados que quería
# Otra opción es sacar datos a nivel fecha-municipio, ordenarlos por p_votos y colorearlo por el color político del ganador, ¿habría una tendencia o conglomerado de colores por p_votos? Hacerlo también por centiles.

datos_participacion_fecha_municipio <- datos_elecciones |> distinct(fecha, cod_mun, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |>   mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |> mutate(censo_quantile = ntile(censo , 10)) |>
    mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)|>
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |> mutate(p_votos_quantile = ntile(p_votos , 10)) |> select(fecha, cod_mun, p_votos, siglas_ganador) |> arrange(-p_votos)

datos_participacion_fecha_municipio

datos_participacion_fecha_municipio |> 
  ggplot()+
  geom_col(aes(x=p_votos_quantile, y=n)) +
  tema_7
```

```{r}
# Otra opción es sacar datos a nivel fecha-municipio, ordenarlos por p_votos y colorearlo por el color político del ganador, ¿habría una tendencia o conglomerado de colores por p_votos? Hacerlo también por centiles.

datos_participacion_fecha_municipio <- datos_elecciones |> distinct(fecha, cod_mun, censo, participacion_1, participacion_2, votos_blancos, votos_nulos, votos_candidaturas) |>   mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |> mutate(censo_quantile = ntile(censo , 10)) |>
    mutate(p_votos=votos/censo, p_participacion_1=participacion_1/censo, p_participacion_2=participacion_2/censo)|>
  left_join(mas_votado1 |> select(fecha,cod_mun,siglas_ganador=siglas)) |> 
  summarise(n=n(),
            p_participacion=mean(p_votos),
            p_participacion_1=mean(p_participacion_1),
            p_participacion_2=mean(p_participacion_2),
            .by=c(censo_quantile,siglas_ganador))


datos_participacion_fecha_municipio
sum(datos_participacion_fecha_municipio$n) # == número de municipios en las seis elecciones
```

Supongamos que existe una relación directa entre censo del municipio y tipo de área: rural o urbana o zonas intermedias.

```{r}
datos_porcentaje_voto |> select(fecha, cod_mun, codigo_ccaa, censo, votos_candidaturas, p_voto) |> 
  mutate(censo_quantile = ntile(censo , 20)) |> 
  left_join(mas_votado1 |> 
              select(fecha, cod_mun,siglas)) |> 
  mutate(siglas2 = if_else(siglas %in% c("PSOE","PP","VOX","CS","MP","UP"),
                                           "part. principales", "part. aut./nac.")) |> 
  ggplot() +
  geom_bar(aes(x=censo_quantile, fill = siglas))+
  facet_wrap(~codigo_ccaa, scales = "free_y")+
  scale_fill_manual(values = cols) +
  tema_7 +
  labs(title = "Distribución de votos según Comunidad autónoma",
       x = "Censo en 20 quintiles",
       y = "Conteo de municipios",
       fill = "Siglas partido")
```

Se aprecia que en las comunidades 09, 13 y 14 la distribución de votos se la llevan partidos políticos que no responden al bipartidismo.

```{r}
#En cada provincia hay cambios de votos hacia los partidos a medida que aumenta el censo
datos_porcentaje_voto |> select(fecha, cod_mun, codigo_ccaa, censo, p_votos_candidaturas) |> mutate(censo_quantile = ntile(censo , 20), .by=codigo_ccaa) |> left_join(mas_votado1 |> select(fecha, cod_mun,siglas)) |> mutate(siglas2 = if_else(siglas %in% c("PSOE","PP","VOX","CS","MP","UP"),
                                           "part. principales", "part. aut./nac.")) |> 
  left_join(colores_politicos) |> 
  ggplot(aes(x=censo_quantile, y=p_votos_candidaturas, fill=siglas))+
  geom_col(position = "fill")+
  facet_wrap(~codigo_ccaa)+
  scale_fill_manual(values = cols) +
  tema_7 +
  labs(title = "Distribución de votos según Comunidad autónoma",
       x = "Censo en 20 quintiles",
       y = "Distribución relativa",
       fill = "Siglas partido")
  # scale_color_manual(aes(values = color_politico))
```

```{r}
data_2 |> # summarise(censo=mean(censo), lag_votos=mean(lag_votos), .by = cod_mun) |> 
  ggplot(aes(x=log(censo), y=log(lag_votos)))+
  geom_point()+
  stat_smooth(method = "lm")+
  tema_7
```

```{r}
datos_elecciones |> distinct(fecha, cod_mun, censo, votos_blancos, votos_nulos, votos_candidaturas) |> 
  mutate(votos=votos_blancos+votos_nulos+votos_candidaturas) |> 
  ggplot(aes(x=(censo), y=(votos)))+
  geom_point()+
  stat_smooth(method = "lm")+
  tema_7
  # facet_wrap(~fecha)
```

## Continuación

```{r}
#| eval: false
pr3 <- datos_elecciones |> 
  group_by(fecha, siglas) |> 
  summarise(suma = sum(votos)) |> 
  group_by(fecha) |> 
  mutate(prop = round(suma/(sum(suma)),2))

pr3 |> 
  group_by(fecha) |> 
  slice_max(suma, n = 2)
```

\newpage

## Bipartidismo en las cámaras

```{r}
#ToDo: poner el filtro de la fecha como el mínimo level de ese factor
parlamento <- datos_elecciones |> 
  filter(fecha=="2008-03") |> 
  summarise(votos=sum(votos), .by = c(fecha, siglas, color_politico))

parlamento <- parlamento |> 
  mutate(asientos = round(350*votos/sum(votos))) |> select(-votos)

semicircle <- parliament_data(election_data = parlamento,
                              type = "semicircle", # Tipo de parlamento
                              parl_rows = 7,      # Número de filas del parlamento
                              party_seats = parlamento$asientos) # Asientos por partido

semi1 <- ggplot(semicircle, aes(x = x, y = y, colour = siglas)) +
  geom_parliament_seats() + 
  theme_ggparliament() +
  labs(title = "Elección de 2008", x="", y="") +
  scale_colour_manual(values = semicircle$color_politico, 
                      limits = semicircle$siglas)+
  tema_7

semi1

#ToDo: poner el filtro de la fecha como el mínimo level de ese factor
parlamento <- datos_elecciones |> 
  filter(fecha=="2019-11") |> 
  summarise(votos=sum(votos), .by = c(fecha, siglas, color_politico))

parlamento <- parlamento |> 
  mutate(asientos = round(350*votos/sum(votos))) |> 
  select(-votos)

semicircle <- parliament_data(election_data = parlamento,
                                 type = "semicircle", # Tipo de parlamento
                                 parl_rows = 7,      # Número de filas del parlamento
                                 party_seats = parlamento$asientos) # Asientos por partido

semi2 <- ggplot(semicircle, aes(x = x, y = y, colour = siglas)) +
  geom_parliament_seats() + 
  theme_ggparliament() +
  labs(title = "Elección de 2019-11", x = "", y = "") +
  scale_colour_manual(values = semicircle$color_politico, 
                      limits = semicircle$siglas) +
  tema_7

semi2
rm(semicircle)
```

\newpage

## Diferencias entre primer y segundo lugar

Ahora, para evaluar estas diferencias entre el primer y el segundo lugar, y evidenciar la distribución espacial de disparidad entre los partidos, se realizó una búsqueda de municipios, provincias y comunidades autónomas en que la disparidad bipartidista es mayor.

## Caso municipios

Para el caso de los municipios, se evaluó aquellos donde el porcentaje de disparidad sea mayor al 50%.

```{r}
pr4 <- datos_elecciones |> 
  filter(censo > 2000) |> 
  group_by(fecha, siglas, municipio) |> 
  summarise(suma = sum(votos)) |> 
  group_by(fecha, municipio) |> 
  mutate(prop = round(suma/(sum(suma)),2)) |> 
  select(-suma)

pr4.1 <- pr4 |> 
  slice_max(prop, n = 2) |> 
  pivot_wider(names_from = siglas, 
              values_from = prop) |> 
  rowwise() |> 
  mutate(primer = max(c_across(PSOE:VOX), na.rm = TRUE)) |> 
  mutate(segundo = min(c_across(PSOE:VOX), na.rm = TRUE)) |> 
  mutate(diferencia = primer-segundo) 

pr4.2 <- pr4.1 |> 
  ungroup() |> 
  filter(diferencia > 0.5) |> 
  nrow()

```

En `r pr4.2` oportunidades, la diferencia entre el primer partido más votado y el siguiente fue mayor al 50%, esto se distribuye de la siguiente forma por votación:

```{r}
#| echo: false
pr4.1 |> 
  ungroup() |> 
  ggplot() +
  geom_histogram(aes(x = diferencia)) +
  facet_wrap(~fecha) +
  labs(
  title = "Distribución de disparidad entre primer y segundo lugar según votación",
  x = "Disparidad entre primer y segundo lugar",
  y = "Número de municipios"
  ) +
  tema_7


pr4.1 |> 
  ungroup() |> 
  filter(diferencia > 0.5) |> 
  summarise(n_de_municipios = n_distinct(municipio), .by = fecha)
```

\newpage

## Diferencias a nivel provincial 

A nivel provincial, se buscaron aquellas provincias con una diferencia mayor al 25%.

```{r}
pr4.22 <- datos_elecciones |> 
  filter(censo > 2000) |> 
  group_by(fecha, siglas, codigo_provincia) |> 
  summarise(suma = sum(votos)) |> 
  group_by(fecha, codigo_provincia) |> 
  mutate(prop = round(suma/(sum(suma)),2)) |> 
  select(-suma)

pr4.3 <- pr4.22 |> 
  slice_max(prop, n = 2) |> 
  pivot_wider(names_from = siglas, 
              values_from = prop) |> 
  rowwise() |> 
  mutate(primer = max(c_across(PSOE:VOX), na.rm = TRUE)) |> 
  mutate(segundo = min(c_across(PSOE:VOX), na.rm = TRUE)) |> 
  mutate(diferencia = primer-segundo) 

pr4.4 <- pr4.3 |> 
  ungroup() |> 
  filter(diferencia > 0.25) |> 
  nrow()

```

En `r pr4.4` oportunidades, la diferencia entre el primer partido más votado y el siguiente fue mayor al 25%, esto se distribuye de la siguiente forma por votación:

```{r}
#| echo: false
pr4.3 |> 
  ungroup() |> 
  ggplot() +
  geom_histogram(aes(x = diferencia)) +
  facet_wrap(~fecha) +
  tema_7 +
  labs(
  title = "Distribución de disparidad entre primer y segundo lugar según votación",
  x = "Disparidad entre primer y segundo lugar",
  y = "Número de provincias"
  )


pr4.3 |> 
  ungroup() |> 
  filter(diferencia > 0.25) |> 
  summarise(n_de_provincias = n_distinct(codigo_provincia), .by = fecha)
```

## Diferencias a nivel comunidad autónoma

Finalmente, en una escala más macro, dado que las diferencias al momento de aumentar la escala son menores, se buscaron aquellas donde la diferencia entre el primer y el segundo lugar sea mayor al 20%.

```{r}
pr4.6 <- datos_elecciones |> 
  filter(censo > 2000) |> 
  group_by(fecha, siglas, codigo_ccaa) |> 
  summarise(suma = sum(votos)) |> 
  group_by(fecha, codigo_ccaa) |> 
  mutate(prop = round(suma/(sum(suma)),2)) |> 
  select(-suma)

pr4.7 <- pr4.6 |> 
  slice_max(prop, n = 2) |> 
  pivot_wider(names_from = siglas, 
              values_from = prop) |> 
  rowwise() |> 
  mutate(primer = max(c_across(PSOE:VOX), na.rm = TRUE)) |> 
  mutate(segundo = min(c_across(PSOE:VOX), na.rm = TRUE)) |> 
  mutate(diferencia = primer-segundo) 

pr4.8 <- pr4.7 |> 
  ungroup() |> 
  filter(diferencia > 0.20) |> 
  nrow()

```

En `r pr4.4` oportunidades, la diferencia entre el primer partido más votado y el siguiente fue mayor al 25%, esto se distribuye de la siguiente forma por votación:

```{r}
#| echo: false
pr4.7 |> 
  ungroup() |> 
  ggplot() +
  geom_histogram(aes(x = diferencia)) +
  facet_wrap(~fecha) +
  tema_7 +
  labs(
  title = "Distribución de disparidad entre primer y segundo lugar según votación",
  x = "Disparidad entre primer y segundo lugar",
  y = "Número de comunidades autónomas"
  )


pr4.7 |> 
  ungroup() |> 
  filter(diferencia > 0.20) |> 
  summarise(n_de_comunidades = n_distinct(codigo_ccaa), .by = fecha)
```

\newpage

## Votos nulos

El voto nulo siempre es un llamado de atención a los políticos, debido a que es una contrarrespuesta a las opciones ofrecidas en las urnas. Al momento de evaluar los municipios que en el promedio de las 6 votaciones evaluadas, poseen los mayores valores de votos nulos, el resultado es el siguiente:

```{r}

pr5 <- datos_elecciones |> 
  mutate(prop_nulo = votos_nulos/votos_candidaturas) |> 
  group_by(municipio) |> 
  summarise(promedio = mean(prop_nulo)) |> 
  mutate('promedio(%)' = round(promedio*100,2)) |> 
  slice_max(promedio, n = 20) |> 
  select(-c(promedio)) 

pr5
```

\newpage

# Participación

El número de votos siempre se ha mantenido por encima de `r format(min_votos, scientific=FALSE)` votos pero, ¿cuánto ha supuesto este número de votos sobre el total de la población?

Comparando la participación con el censo para cada una de las elecciones:

```{r}
data_1 |> 
  summarise(votos = sum(votos), .by = c(fecha, censo)) |> 
  mutate(p_votos = votos/censo) |> 
  ggplot(aes(x = fecha)) +
  geom_col(aes(y = censo)) +
  tema_7 +
  geom_hline(yintercept = mean(participacion$participacion)*(1/0.00000003), 
             linetype = "dashed", color = "white", linewidth = 0.5) +
  geom_line(aes(y = p_votos*(1/0.00000003)),group = 1, color = "#e3005a") +
  scale_y_continuous(name = "Número de votos", sec.axis = sec_axis(~.*0.00000003, name = "Participación (%)")) +
  scale_y_break(c(500000, 20000000)) +
  labs(
    title = "Participación por número de votos y fecha",
    x = "Fecha de elección"
  )
```

El número de censados aumenta y la participación parece que va a la baja, aunque con seis evaluaciones no se puede afirmar con seguridad. Al comienzo de 2019 hay un repunte de la participación, pero de nuevo vuelve a bajar, posiblemente por el "aburrimiento" de volver a votar en ese mismo año.

\newpage

Miramos el peso que han tenido las personas censadas que no han votado versus el total de votos por cada una de las elecciones.

# Mario Esto estaba tirando error por el gif

```{r}
#| eval: false
#gif_image <- image_read("https://raw.githubusercontent.com/MarioC0093/Software_GRUPAL_7/main/desarrollo_Mario/votar.gif") |>  image_scale("150")

# fig <- image_graph(width = 300, height = 400)
#fig <- image_graph()

data_1 |> summarise(votos=sum(votos),.by=c(fecha, censo)) |> mutate(no_votos=censo-votos) |>
  pivot_longer(cols = c(votos, no_votos), names_to = "tipo_voto") |> 
  ggplot() +
  geom_col(aes(x=fecha, y=value, fill=tipo_voto), position = "fill")+
  tema_7


# Composing the full image
# out <- image_composite(fig, gif_image, offset = "+00+100",  gravity = "center")
out <- image_composite(fig, gif_image, offset = "+120+75",  gravity = "southeast")


# Animation of the image
animation <- image_animate(out, fps = 10, optimize = TRUE)

# Show the image
print(animation, info = FALSE) 
```

Al igual que al inicio veíamos los votos recibidos por cada partida, ahora incluímos ese *no voto* como una representatividad más.

```{r}
# ToDo: reordenar los factores para que no_votos salga arriba del todo
data_1 |> summarise(votos=sum(votos),.by=c(fecha, censo)) |> mutate(no_votos=censo-votos) |>
  pivot_longer(cols = c(votos, no_votos), names_to = "tipo_voto") |>
  filter(tipo_voto=="no_votos") |> select(fecha, siglas=tipo_voto, votos=value) |>
  rbind(data_1 |> summarise(votos=sum(votos),.by=c(fecha, siglas))) |> 
  ggplot() +
  geom_col(aes(x=fecha, y=votos, fill=siglas), position = "fill") +
  scale_fill_manual(values = cols) +
  tema_7 +
  labs(
    title = "Proporción de votos por partido político",
    x = "Fecha de elección",
    y = "Proporción de votos"
  )
  

rm(data_1)
```

\newpage

# Participación MARIO: dejaría lo tuyo en vez de esto

En contraste a lo anterior, los municipios que poseen un mayor porcentaje de participación en las urnas, son los siguientes:

```{r}
datos_porcentaje_voto <- datos_elecciones |> distinct(fecha,cod_mun,municipio,codigo_ccaa,censo,votos_blancos,votos_nulos,votos_candidaturas) |>
  mutate(votos_municipio = votos_blancos + votos_nulos + votos_candidaturas,
         p_votos_blancos = round(votos_blancos/censo,2),
         p_votos_nulos = round(votos_nulos/censo,2),
         p_votos_candidaturas = round(votos_candidaturas/censo,2),
         p_voto = round(votos_municipio/censo,2))

# datos_porcentaje_voto <- datos_porcentaje_voto |> left_join(mas_votado, by = c("fecha","cod_mun"))
```

```{r}
datos_porcentaje_voto |>  mutate(censo_quantile = ntile(censo , 10)) |> summarise(p_voto=mean(p_voto), .by = censo_quantile) |> 
  ggplot() +
  geom_col(aes(x=censo_quantile, y=p_voto)) +
  scale_x_continuous(breaks = 1:10) +
  labs(
    title = "Participación versus censo",
    x = "Deciles de censos",
    y = "Participación (%)"
  ) +
  tema_7


```

Se puede evidenciar que la participación es mayor en los municipios de menor tamaño poblacional, y que ésta decrece a medida que la población del municipio aumenta.

\newpage

## Municipios de mayor participación

Al momento de evaluar solo aquellos municipios correspondientes al 30% de mayor participación, los resultados apuntan a lo siguiente:

```{r}
pr6.0 <- datos_porcentaje_voto |> 
  mutate(censo_quantile = ntile(censo , 10)) |> 
  filter(censo_quantile < 4) |> 
  left_join(datos_elecciones, by= c("municipio" = "municipio", "fecha" = "fecha")) |> 
  group_by(fecha, siglas) |> 
  summarise(sumavotos = sum(votos)) |> 
  slice_max(sumavotos, n = 1)

pr6 <- datos_porcentaje_voto |> 
  mutate(censo_quantile = ntile(censo , 10)) |> 
  filter(censo_quantile < 4) |> 
  left_join(datos_elecciones, by= c("municipio" = "municipio", "fecha" = "fecha")) |> 
  group_by(fecha, siglas) |> 
  summarise(sumavotos = sum(votos))

pr6 |> 
  ggplot(aes(x = fecha, y = sumavotos, fill = siglas)) +
  geom_col(position = "fill") + 
  #geom_text(aes(label = (prop*100)), position = position_fill(0.5)) +
  tema_7 + 
  scale_fill_manual(values = cols) +
  theme(legend.position = "bottom") +
  labs(
    title = "Proporción de votos en cada elección por partido",
    caption = "Solo considerando municipios con más de 100.000 habitantes.",
    x = "Fecha de elección",
    y = "Proporción de votos",
    fill = "Partido político"
  )

```

Se evidencia que el PP sale triunfante en todas las elecciones en los municipios donde hay mayor participación.

\newpage

## Menor participación

Por otro lado, al momento de evaluar aquellos municipios correspondientes al 30% donde hay una menor participación, que se condicen con ser los municipios de mayor población, los resultados apuntan a lo siguiente:

```{r}
pr6.1 <- datos_porcentaje_voto |> 
  mutate(censo_quantile = ntile(censo , 10)) |> 
  filter(censo_quantile > 4) |> 
  left_join(datos_elecciones, by= c("municipio" = "municipio", "fecha" = "fecha")) |> 
  group_by(fecha, siglas) |> 
  summarise(sumavotos = sum(votos)) |> 
  slice_max(sumavotos, n = 1) |> 
  left_join(pr6.0, by = c("fecha" = "fecha")) |> 
  rename(partido_baja_partic = siglas.x,
         votos_baja_partic = sumavotos.x,
         partido_alta_partic = siglas.y,
         votos_alta_partic = sumavotos.y)
  


pr6.2 <- datos_porcentaje_voto |> 
  mutate(censo_quantile = ntile(censo , 10)) |> 
  filter(censo_quantile > 4) |> 
  left_join(datos_elecciones, by= c("municipio" = "municipio", "fecha" = "fecha")) |> 
  group_by(fecha, siglas) |> 
  summarise(sumavotos = sum(votos))

#AGREGAR TITULO, CORREGIR LEYENDA, CORREGIR NOMBRES DE EJES
pr6.2 |> 
  ggplot(aes(x = fecha, y = sumavotos, fill = siglas)) +
  geom_col(position = "fill") + 
  #geom_text(aes(label = (prop*100)), position = position_fill(0.5)) +
  tema_7 + 
  scale_fill_manual(values = cols) +
  theme(legend.position = "bottom") +
  labs(
    title = "Proporción de votos en cada elección por partido",
    caption = "Solo considerando municipios con más de 100.000 habitantes.",
    x = "Fecha de elección",
    y = "Proporción de votos",
    fill = "Partido político"
  )

pr6.1 |> 
  select(fecha, partido_baja_partic, votos_baja_partic)
```

En aquellos municipios con menor participación, los partidos triunfadores son el PP y el PSOE según la votación.

\newpage

## Partidos beneficiados por menor y mayor participación

Por otro lado, al revisar aquellos municipios donde hay una alta participación, se evidencia lo siguiente:

```{r}
pr6.1 
```

En base a lo anterior, se puede evidenciar que la baja participación, que ocurre en los municipios de mayor población beneficia al PSOE, mas no en todas las elecciones. Aquellos municipios de mayor población suelen ser los municipios más urbanizados, por lo tanto en aquellos municipios rurales el PP pareciera beneficiarse, y en aquellos municipios urbanizados, el PSOE es quien toma ciertas ventajas.

\newpage

# Encuestas

## MARIO CHEQUEA PORFA QUE PASA CON LAS SIGLAS DE LAS ENCUESTAS ¿PARECE QUE IU DEBERÍA UNIRSE A UP? 

## Una vez tengamos eso hay que hacer el factor de las siglas de nuevo, porque otros queda raro

Desde 2008 a 2019 se han realizado `r encuestas |> distinct(pollster) |> nrow()` encuestas, con valores muestrales que van desde `r encuestas |>  summarise(min(size)) |> pull()` a `r encuestas |>  summarise(max(size)) |> pull()` personas.

```{r}
enc01 <- encuestas |> 
  mutate(date_elec = as.Date(date_elec, format = "%Y-%m-%d")) |> 
  mutate(fecha = format(date_elec, "%Y-%m")) |> 
  group_by(fecha, siglas) |> 
  summarise(estim_voto = (mean(estimacion_votos)/100)) 

enc02 <- pr2 |> 
  left_join(enc01) |> 
  rename(Encuestas = estim_voto,
         Resultado = prop) |> 
  pivot_longer(c(Resultado, Encuestas),
    values_to = "votos",
    names_to = "origen"
  )

enc02 |> 
  ggplot() +
  geom_col(aes(x = siglas, y = votos, fill = origen), position = position_dodge()) +
  facet_wrap(~fecha) +
  coord_flip() +
  labs(
    title = "Diferencia entre estimación de encuestas y resultados",
    x = "Porcentaje de votos",
    y = "Partidos políticos",
    fill = "Fuente del dato"
  ) +
  scale_fill_manual(values = colores) +
  tema_7


```

Dado que cada votación y cada encuesta presenta valores diferentes, esto las vuelve poco calibrables para los gestores de datos, se vuelve necesario hacer un análisis al detalle de cada elección para calibrar cada una de ellas.

\newpage

```{r}
### Generación de boxplot

enc03 <- encuestas |> 
  mutate(date_elec = as.Date(date_elec, format = "%Y-%m-%d")) |> 
  mutate(fecha = format(date_elec, "%Y-%m")) |> 
  group_by(fecha, siglas)

enc04 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |> 
  select(fecha, siglas, prop, encuestas)

enc04 |> 
  ggplot() +
  geom_boxplot(aes(x = siglas, y = encuestas), alpha = 0.9) +
  geom_point(aes(x = siglas, y = prop), color = "red") +
  facet_wrap(~fecha, scales = "free_y") +
  coord_flip() +
  tema_7+
  labs(
    title = "Error asociado a cada encuesta",
    x = "Partidos políticos",
    y = "Error de las encuestas",
    caption = "En rojo el resultado final en esa votación"
  )

#Prueba a nivel nacional
enc04 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |> 
  select(fecha, siglas, prop, encuestas) |> 
  mutate(dif = encuestas - prop)

enc04 |> 
  ggplot() +
  geom_boxplot(aes(x = fecha, y = dif), na.rm = TRUE, alpha = 0.9) +
  #geom_point(aes(x = siglas, y = dif), color = "red") +
  coord_flip() +
  labs(
    title = "Error asociado a cada votación",
    x = "Fecha de votación",
    y = "Diferencia del valor estimado por las encuestas"
  )+
  tema_7

```

\newpage

## Encuestas menos precisas

```{r}
enc05 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |>
  ungroup() |> 
  summarise(prom_enc = round(mean(encuestas),2), .by = c(fecha, siglas)) |> 
  left_join(pr2) |> 
  mutate(dif = abs(prom_enc - prop)) |> 
  summarise(prom_dif = mean(dif, na.rm = TRUE), .by = fecha)

enc05 |> 
  ggplot() +
  geom_point(aes(x = fecha, y = prom_dif), shape = 3, size = 4) +
  tema_7 +
  labs(
    title = "Diferencias entre resultados estimados por encuestas y resultados de elecciones",
    x = "Fecha votación",
    y = "Diferencia promedio entre encuesta y resultado elección"
  )

```

Las encuestas se equivocaron más en la elección del 2011-11, seguida del 2016-06 y 2019-11. Curiosamente en las elecciones de 2019-04 el promedio de las encuestas estuvo bastante cerca del resultado final.

\newpage

## Error de encuestas en partidos de ámbito nacional

```{r}
enc06 <- pr2 |> 
  left_join(enc03) |> 
  mutate(encuestas = estimacion_votos/100) |> 
  select(fecha, siglas, prop, encuestas) |> 
  filter(siglas %in% c("PSOE","PP", "VOX", "CS", "MP", "UP", "IU"))

enc06 |> 
  ggplot() +
  geom_boxplot(aes(x = siglas, y = encuestas), alpha = 0.9) +
  geom_point(aes(x = siglas, y = prop), color = "red") +
  facet_wrap(~fecha, scales = "free_y") +
  coord_flip() +
  tema_7 +
  labs(
    title = "Error asociado a cada encuesta, solo partidos de ámbito nacional",
    x = "Partidos políticos",
    y = "Error de las encuestas",
    caption = "En rojo el resultado final en esa votación"
  )

```

Se evidencia que las encuestas previeron resultados disímiles respecto a los partidos de ámbito nacional, como aquellas del 2019, donde al PSOE lo subestiman en abril y luego lo sobrestiman en noviembre, caso contrario para el PP en el mismo rango.

\newpage

## Casas encuestadoras

```{r}
#| results: hold
enc07 <- encuestas |> 
  mutate(date_elec = as.Date(date_elec, format = "%Y-%m-%d")) |> 
  mutate(fecha = format(date_elec, "%Y-%m")) |> 
  group_by(fecha, siglas, id_pollster)

enc08 <- pr2 |> 
  left_join(enc07) |> 
  mutate(estimado = estimacion_votos/100) |> 
  pivot_longer(c(prop),
    values_to = "votos") |> 
  mutate(dif = abs(estimado - votos))

enc08 |> 
  ggplot() +
  geom_boxplot(aes(x = fct_rev(pollster), y = dif), na.rm = TRUE, 
               outlier.shape = 10, 
               outlier.alpha = 0.8) +
  #geom_point(aes(x = siglas, y = dif), color = "red") +
  coord_flip() +
  tema_7 +
  labs(
    title = "Error asociado a cada casa encuestadora",
    x = "Casa encuestadora",
    y = "Diferencia del valor estimado por las encuestas"
  )

```

Se puede apreciar que las casas CIS, ENCUESTAMOS y MYWORD presentan los rangos más amplios de resultados, y CELESTE-TEL la que presenta más outliers.
